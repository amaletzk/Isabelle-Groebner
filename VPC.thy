section \<open>Valid Polygonial Chains\<close>

theory VPC
  imports Binomials Binom_Mult
begin

subsection \<open>Preliminaries\<close>

text \<open>Since most results in this theory are concerned with ideals generated by two polynomials, we
  prove some specific properties of such ideals.\<close>

lemma in_idealI_2: "q1 * f1 + q2 * f2 \<in> ideal {f1, f2::'a::comm_powerprod \<Rightarrow>\<^sub>0 'b::comm_ring_1}"
  by (rule ideal.span_add, rule ideal.span_scale, rule ideal.span_base,
      simp, rule ideal.span_scale, rule ideal.span_base, simp)

lemma in_idealE_2:
  assumes "f \<in> ideal {f1, f2}"
  obtains q1 q2 where "f = q1 * f1 + q2 * f2"
  using assms
proof (induct f arbitrary: thesis rule: ideal.span_induct')
  case base
  show ?case
  proof (rule base)
    show "0 = 0 * f1 + 0 * f2" by simp
  qed
next
  case (step f' c g)
  obtain q1 q2 where f'_eq: "f' = q1 * f1 + q2 * f2" by (rule step(2))
  from step(3) have "g = f1 \<or> g = f2" by simp
  thus ?case
  proof
    assume "g = f1"
    show ?case
    proof (rule step(5))
      show "f' + c * g = (q1 + c) * f1 + q2 * f2" by (simp add: f'_eq \<open>g = f1\<close> algebra_simps)
    qed
  next
    assume "g = f2"
    show ?case
    proof (rule step(5))
      show "f' + c * g = q1 * f1 + (q2 + c) * f2" by (simp add: f'_eq \<open>g = f2\<close> algebra_simps)
    qed
  qed
qed

lemma in_ideal_iff_2:
  "f \<in> ideal {f1, f2} \<longleftrightarrow> (\<exists>q1 q2. f = q1 * f1 + q2 * (f2::'a::comm_powerprod \<Rightarrow>\<^sub>0 'b::comm_ring_1))"
proof
  assume "f \<in> ideal {f1, f2}"
  then obtain q1 q2 where "f = q1 * f1 + q2 * f2" by (rule in_idealE_2)
  show "\<exists>q1 q2. f = q1 * f1 + q2 * f2" by (intro exI, fact)
next
  assume "\<exists>q1 q2. f = q1 * f1 + q2 * f2"
  then obtain q1 q2 where f_eq: "f = q1 * f1 + q2 * f2" by auto
  show "f \<in> ideal {f1, f2}" unfolding f_eq by (rule in_idealI_2)
qed

lemma scalar_binomial:
  "a \<cdot> binomial c s d t = binomial (a * c) s (a * (d::_::semiring_0)) (t::_::comm_powerprod)"
  by (simp add: scalar_eq_monom_mult punit.monom_mult_binomial)

definition is_nat_pm_pair :: "(('x \<Rightarrow>\<^sub>0 'b) * ('x \<Rightarrow>\<^sub>0 'b::floor_ceiling)) \<Rightarrow> bool" where
  "is_nat_pm_pair pp = (is_nat_pm (fst pp) \<and> is_nat_pm (snd pp))"

definition is_int_pm_pair :: "(('x \<Rightarrow>\<^sub>0 'b) * ('x \<Rightarrow>\<^sub>0 'b::floor_ceiling)) \<Rightarrow> bool" where
  "is_int_pm_pair pp = (is_int_pm (fst pp) \<and> is_int_pm (snd pp))"
  
lemma is_nat_pm_pairI: "is_nat_pm (fst pp) \<Longrightarrow> is_nat_pm (snd pp) \<Longrightarrow> is_nat_pm_pair pp"
  unfolding is_nat_pm_pair_def ..
    
lemma is_nat_pm_pairD:
  assumes "is_nat_pm_pair pp"
  shows "is_nat_pm (fst pp)" and "is_nat_pm (snd pp)"
  using assms by (simp_all add: is_nat_pm_pair_def)

lemma is_int_pm_pairI: "is_int_pm (fst pp) \<Longrightarrow> is_int_pm (snd pp) \<Longrightarrow> is_int_pm_pair pp"
  unfolding is_int_pm_pair_def ..
    
lemma is_int_pm_pairD:
  assumes "is_int_pm_pair pp"
  shows "is_int_pm (fst pp)" and "is_int_pm (snd pp)"
  using assms by (simp_all add: is_int_pm_pair_def)
    
lemma nat_pm_pair_is_int_pm_pair: "is_nat_pm_pair pp \<Longrightarrow> is_int_pm_pair pp"
  by (auto intro: is_int_pm_pairI dest: is_nat_pm_pairD nat_pm_is_int_pm)

abbreviation "rat \<equiv> rat_of_nat"

type_synonym 'x point = "('x \<Rightarrow>\<^sub>0 rat)"

definition deg_pair :: "('x point \<times> 'x point) \<Rightarrow> rat"
  where "deg_pair pp = max (deg_pm (fst pp)) (deg_pm (snd pp))"

context pm_powerprod
begin

lemma scalar_mono:
  assumes "m \<le> n"
  shows "m \<cdot> t \<preceq> n \<cdot> t"
proof -
  have "m \<cdot> t \<preceq> m \<cdot> t + (n - m) \<cdot> t" using zero_min plus_monotone_left by fastforce
  also have "\<dots> = (m + (n - m)) \<cdot> t" by (simp only: scalar_distrib_right)
  also from assms have "\<dots> = n \<cdot> t" by simp
  finally show ?thesis .
qed

lemma scalar_mono_left:
  assumes "s \<preceq> t"
  shows "m \<cdot> s \<preceq> m \<cdot> t"
proof (induct m)
  case 0
  show ?case by simp
next
  case (Suc m)
  have "Suc m \<cdot> s = (m + 1) \<cdot> s" by simp
  also have "\<dots> = m \<cdot> s + s" by (simp only: scalar_distrib_right scalar_one_left)
  also from Suc have "\<dots> \<preceq> m \<cdot> t + s" by (rule plus_monotone)
  also from assms have "\<dots> \<preceq> m \<cdot> t + t" by (rule plus_monotone_left)
  also have "\<dots> = (m + 1) \<cdot> t" by (simp only: scalar_distrib_right scalar_one_left)
  also have "\<dots> = Suc m \<cdot> t" by simp
  finally show ?case .
qed

lemma scalar_mono_strict:
  assumes "m < n" and "t \<noteq> 0"
  shows "m \<cdot> t \<prec> n \<cdot> t"
proof -
  from assms(1) have "m \<le> n" by simp
  hence "m \<cdot> t \<preceq> n \<cdot> t" by (rule scalar_mono)
  moreover have "m \<cdot> t \<noteq> n \<cdot> t"
  proof
    from assms(2) obtain x where "0 < lookup t x" using aux by auto
    assume "m \<cdot> t = n \<cdot> t"
    hence "lookup (m \<cdot> t) x = lookup (n \<cdot> t) x" by simp
    with \<open>0 < lookup t x\<close> assms(1) show False by simp
  qed
  ultimately show ?thesis by simp
qed

lemma scalar_mono_strict_left:
  assumes "s \<prec> t" and "0 < m"
  shows "m \<cdot> s \<prec> m \<cdot> t"
proof -
  from assms(1) have "s \<preceq> t" by simp
  hence "m \<cdot> s \<preceq> m \<cdot> t" by (rule scalar_mono_left)
  moreover have "m \<cdot> s \<noteq> m \<cdot> t"
  proof
    from assms(1) have "s \<noteq> t" by simp
    then obtain x where "lookup s x \<noteq> lookup t x" by (meson poly_mapping_eqI)
    with assms(2) have "lookup (m \<cdot> s) x \<noteq> lookup (m \<cdot> t) x" by simp
    moreover assume "m \<cdot> s = m \<cdot> t"
    ultimately show False by simp
  qed
  ultimately show ?thesis by simp
qed

definition poly_point :: "(('x \<Rightarrow>\<^sub>0 nat) \<Rightarrow>\<^sub>0 'b::zero) \<Rightarrow> ('x point \<times> 'x point)" where
  "poly_point p = (of_nat_pm (lp p), of_nat_pm (tp p))"

definition vect :: "(('x \<Rightarrow>\<^sub>0 nat) \<Rightarrow>\<^sub>0 'b::zero) \<Rightarrow> ('x point)"
  where "vect p = fst (poly_point p) - snd (poly_point p)"

lemma fst_poly_point: "fst (poly_point p) = of_nat_pm (lp p)"
  by (simp add: poly_point_def)
    
lemma snd_poly_point: "snd (poly_point p) = of_nat_pm (tp p)"
  by (simp add: poly_point_def)

lemma poly_point_is_nat_pm_pair: "is_nat_pm_pair (poly_point p)"
  unfolding poly_point_def by (rule is_nat_pm_pairI, simp_all, (rule of_nat_pm_is_nat_pm)+)

lemma poly_point_is_int_pm_pair: "is_int_pm_pair (poly_point p)"
  using poly_point_is_nat_pm_pair by (rule nat_pm_pair_is_int_pm_pair)

lemma swap_poly_point_not_eq:
  assumes "is_proper_binomial p"
  shows "prod.swap (poly_point p) \<noteq> poly_point q"
proof
  assume "prod.swap (poly_point p) = poly_point q"
  hence 1: "lp p = tp q" and 2: "tp p = lp q" by (simp_all add: poly_point_def)
  from assms(1) have "tp p \<prec> lp p" by (rule punit.lt_gr_tt_binomial)
  hence "lp q \<prec> tp q" by (simp only: 1 2)
  with punit.lt_ge_tt[of q] show False by simp
qed

corollary swap_poly_point_not_eq':
  assumes "is_proper_binomial q"
  shows "prod.swap (poly_point p) \<noteq> poly_point q"
proof
  assume *: "prod.swap (poly_point p) = poly_point q"
  from assms have "prod.swap (poly_point q) \<noteq> poly_point p" by (rule swap_poly_point_not_eq)
  moreover from *[symmetric] have "prod.swap (poly_point q) = poly_point p" by simp
  ultimately show False ..
qed

lemma vect_alt: "vect p = of_nat_pm (lp p) - of_nat_pm (tp p)"
  by (simp only: vect_def fst_poly_point snd_poly_point)

lemma vect_is_int_pm: "is_int_pm (vect p)"
  by (simp add: vect_def is_int_pm_pairD[OF poly_point_is_int_pm_pair] is_int_pm_pairD minus_is_int_pm)

end

locale two_polys =
  pm_powerprod ord ord_strict
  for ord::"('x \<Rightarrow>\<^sub>0 nat) \<Rightarrow> ('x::countable \<Rightarrow>\<^sub>0 nat) \<Rightarrow> bool" (infixl "\<preceq>" 50)
  and ord_strict (infixl "\<prec>" 50) +
  fixes f1 f2 :: "('x \<Rightarrow>\<^sub>0 nat) \<Rightarrow>\<^sub>0 'b::field"
begin

definition overlap :: "'x point"
  where "overlap = lcs (gcs (fst (poly_point f1)) (snd (poly_point f1)))
                       (gcs (fst (poly_point f2)) (snd (poly_point f2)))"

lemma overlap_alt:
  "overlap = lcs (gcs (of_nat_pm (lp f1)) (of_nat_pm (tp f1)))
                 (gcs (of_nat_pm (lp f2)) (of_nat_pm (tp f2)))"
  by (simp only: overlap_def fst_poly_point snd_poly_point)

lemma overlap_alt': "overlap = of_nat_pm (lcs (gcs (lp f1) (tp f1)) (gcs (lp f2) (tp f2)))"
  by (simp add: overlap_alt gcs_of_nat_pm lcs_of_nat_pm)

lemma overlap_is_nat_pm: "is_nat_pm overlap"
  by (simp add: overlap_def is_nat_pm_pairD[OF poly_point_is_nat_pm_pair] gcs_is_nat_pm lcs_is_nat_pm)

lemma gcs_le_overlap:
  shows "gcs (of_nat_pm (lp f1)) (of_nat_pm (tp f1)) \<unlhd> overlap"
    and "gcs (of_nat_pm (lp f2)) (of_nat_pm (tp f2)) \<unlhd> overlap"
  by (simp_all add: overlap_alt le_pm_def lookup_lcs_fun leq_lcs_fun_1 leq_lcs_fun_2)

lemma gcs_le_overlap':
  shows "of_nat_pm (gcs (lp f1) (tp f1)) \<unlhd> overlap" and "of_nat_pm (gcs (lp f2) (tp f2)) \<unlhd> overlap"
  using gcs_le_overlap by (simp_all add: gcs_of_nat_pm)

lemma overlap_is_int_pm: "is_int_pm overlap"
  using overlap_is_nat_pm by (rule nat_pm_is_int_pm)

lemma lem_3_1_13:
  assumes "of_nat_pm (tp f1) \<unlhd> p" and "of_nat_pm (tp f2) \<unlhd> p"
  shows "overlap \<unlhd> p"
  unfolding overlap_alt lookup_lcs_fun le_pm_def
proof (rule lcs_leq_fun)
  let ?t = "of_nat_pm (lp f1)"
  let ?s = "of_nat_pm (tp f1)"
  have "lookup (gcs ?t ?s) \<le> lookup ?s" unfolding lookup_gcs_fun by (fact gcs_leq_fun_2)
  also from assms(1) have "... \<le> lookup p" by (simp only: le_pm_def)
  finally show "lookup (gcs ?t ?s) \<le> lookup p" .
next
  let ?t = "of_nat_pm (lp f2)"
  let ?s = "of_nat_pm (tp f2)"
  have "lookup (gcs ?t ?s) \<le> lookup ?s" unfolding lookup_gcs_fun by (fact gcs_leq_fun_2)
  also from assms(2) have "... \<le> lookup p" by (simp only: le_pm_def)
  finally show "lookup (gcs ?t ?s) \<le> lookup p" .
qed

subsection \<open>VPCs\<close>

definition shifts :: "('x point \<times> 'x point) set"
  where "shifts = (let A = {poly_point f1, poly_point f2} in A \<union> prod.swap ` A)"

lemma shiftsI1: "s = poly_point f1 \<Longrightarrow> s \<in> shifts"
  by (simp add: shifts_def)

lemma shiftsI2: "s = poly_point f2 \<Longrightarrow> s \<in> shifts"
  by (simp add: shifts_def)

lemma shiftsI3: "s = prod.swap (poly_point f1) \<Longrightarrow> s \<in> shifts"
  by (simp add: shifts_def)

lemma shiftsI4: "s = prod.swap (poly_point f2) \<Longrightarrow> s \<in> shifts"
  by (simp add: shifts_def)

lemma shiftsE:
  assumes "s \<in> shifts"
  obtains "s = poly_point f1" | "s = poly_point f2" |
          "s = prod.swap (poly_point f1)" | "s = prod.swap (poly_point f2)"
  using assms by (auto simp: shifts_def)

definition nat_plus_point_pair :: "('x \<Rightarrow>\<^sub>0 nat) \<Rightarrow> ('x point \<times> 'x point) \<Rightarrow> ('x point \<times> 'x point)" (infixl "+\<^sub>N" 70)
  where "nat_plus_point_pair t pp = (of_nat_pm t + fst pp, of_nat_pm t + snd pp)"

abbreviation "Nshifts \<equiv> case_prod (+\<^sub>N) ` (UNIV \<times> shifts)"

lemma NshiftsI: "z = t +\<^sub>N s \<Longrightarrow> s \<in> shifts \<Longrightarrow> z \<in> Nshifts"
  by auto

lemma NshiftsE:
  assumes "z \<in> Nshifts"
  obtains t s where "s \<in> shifts" and "z = t +\<^sub>N s"
  using assms by auto

definition is_vpc :: "('x point \<times> 'x point) list \<Rightarrow> bool"
  where "is_vpc zs \<longleftrightarrow> zs \<noteq> [] \<and> (\<forall>i<length zs - 1. snd (zs ! i) = fst (zs ! Suc i)) \<and>
                      set zs \<subseteq> Nshifts"

lemma is_vpcI:
  "zs \<noteq> [] \<Longrightarrow> (\<And>i. Suc i < length zs \<Longrightarrow> snd (zs ! i) = fst (zs ! Suc i)) \<Longrightarrow> set zs \<subseteq> Nshifts \<Longrightarrow>
    is_vpc zs"
  by (simp add: is_vpc_def)

lemma is_vpcD:
  assumes "is_vpc zs"
  shows "zs \<noteq> []" and "Suc i < length zs \<Longrightarrow> snd (zs ! i) = fst (zs ! Suc i)" and "set zs \<subseteq> Nshifts"
  using assms by (simp_all add: is_vpc_def)

lemma is_vpcE:
  assumes "is_vpc zs" and "z \<in> set zs"
  obtains t s where "s \<in> shifts" and "z = t +\<^sub>N s"
  using assms by (auto dest!: is_vpcD(3))

lemma is_vpc_take: "is_vpc zs \<Longrightarrow> 0 < n \<Longrightarrow> is_vpc (take n zs)"
  using set_take_subset[of n zs] by (auto intro!: is_vpcI dest: is_vpcD)

lemma is_vpc_drop:
  assumes "is_vpc zs" and "n < length zs"
  shows "is_vpc (drop n zs)"
proof (rule is_vpcI)
  from assms(2) show "drop n zs \<noteq> []" by simp
next
  fix i
  assume "Suc i < length (drop n zs)"
  with assms(2) have *: "Suc (n + i) < length zs" by simp
  from assms(2) have "snd (drop n zs ! i) = snd (zs ! (n + i))" by simp
  also from assms(1) * have "\<dots> = fst (zs ! Suc (n + i))" by (rule is_vpcD)
  also from assms(2) have "\<dots> = fst (drop n zs ! Suc i)" by simp
  finally show "snd (drop n zs ! i) = fst (drop n zs ! Suc i)" .
next
  from assms(1) have "set zs \<subseteq> Nshifts" by (rule is_vpcD)
  with set_drop_subset show "set (drop n zs) \<subseteq> Nshifts" by (rule subset_trans)
qed

lemma is_vpc_singleton [simp]: "is_vpc [z] \<longleftrightarrow> z \<in> Nshifts"
  by (simp add: is_vpc_def)

lemma is_vpc_append:
  assumes "is_vpc zs1" and "is_vpc zs2" and "snd (last zs1) = fst (hd zs2)"
  shows "is_vpc (zs1 @ zs2)"
proof (rule is_vpcI)
  from assms(2) have "zs2 \<noteq> []" by (rule is_vpcD)
  from assms(1) have "zs1 \<noteq> []" by (rule is_vpcD)
  thus "zs1 @ zs2 \<noteq> []" by simp

  fix i
  assume 1: "Suc i < length (zs1 @ zs2)"
  show "snd ((zs1 @ zs2) ! i) = fst ((zs1 @ zs2) ! Suc i)"
  proof (rule linorder_cases)
    assume 2: "Suc i < length zs1"
    with assms(1) have "snd (zs1 ! i) = fst (zs1 ! Suc i)" by (rule is_vpcD)
    with 2 show ?thesis by (simp add: nth_append)
  next
    assume 2: "Suc i = length zs1"
    hence 3: "i = length zs1 - 1" and "i < length zs1" by simp_all
    have "snd ((zs1 @ zs2) ! i) = snd (zs1 ! i)" by (simp add: nth_append \<open>i < length zs1\<close>)
    also from \<open>zs1 \<noteq> []\<close> have "\<dots> = snd (last zs1)" by (simp add: last_conv_nth 3)
    also have "\<dots> = fst (hd zs2)" by fact
    also from \<open>zs2 \<noteq> []\<close> have "\<dots> = fst (zs2 ! 0)" by (simp add: hd_conv_nth)
    also have "\<dots> = fst ((zs1 @ zs2) ! (Suc i))" by (simp add: nth_append 2)
    finally show ?thesis .
  next
    assume 2: "length zs1 < Suc i"
    with 1 have "Suc (i - length zs1) < length zs2" by simp
    with assms(2) have "snd (zs2 ! (i - length zs1)) = fst (zs2 ! Suc (i - length zs1))" by (rule is_vpcD)
    with 2 show ?thesis by (simp add: nth_append Suc_diff_le)
  qed
next
  from assms(1) have "set zs1 \<subseteq> Nshifts" by (rule is_vpcD)
  moreover from assms(2) have "set zs2 \<subseteq> Nshifts" by (rule is_vpcD)
  ultimately show "set (zs1 @ zs2) \<subseteq> Nshifts" by simp
qed

lemma is_vpc_Cons:
  assumes "is_vpc zs" and "z \<in> Nshifts" and "snd z = fst (hd zs)"
  shows "is_vpc (z # zs)"
proof -
  have "is_vpc ([z] @ zs)" by (rule is_vpc_append) (simp_all add: assms)
  thus ?thesis by simp
qed

context
  assumes f1_pbinomial: "is_proper_binomial f1"
  assumes f2_pbinomial: "is_proper_binomial f2"
begin

lemma lem_3_3_11:
  assumes "f = q1 * f1 + q2 * f2" and "card (keys f) = 3" and "t \<in> keys f" and "t' \<in> keys f"
    and "t \<noteq> t'" and "monomial 1 t \<notin> ideal {f1, f2}" and "monomial 1 t' \<notin> ideal {f1, f2}"
  obtains q1' q2' c where "c \<noteq> 0" and "keys q1' \<subseteq> keys q1" and "keys q2' \<subseteq> keys q2"
    and "q1' * f1 + q2' * f2 = binomial (lookup f t) t c t'"
proof -
  define k where "k = card (keys q1) + card (keys q2)"
  from wf_less[to_pred] assms k_def that show ?thesis
  proof (induct k arbitrary: thesis q1 q2 f t t' rule: wfP_induct_rule)
    case (less k)
    have "keys f - {t, t'} \<noteq> {}"
    proof
      assume "keys f - {t, t'} = {}"
      hence "keys f \<subseteq> {t, t'}" by simp
      hence "card (keys f) \<le> card {t, t'}" by (auto intro: card_mono)
      also from less.prems(5) have "\<dots> = 2" by simp
      finally show False using less.prems(2) by simp
    qed
    then obtain t'' where "t'' \<in> keys f - {t, t'}" by blast
    hence "t'' \<in> keys f" and "t \<noteq> t''" and "t' \<noteq> t''" by blast+
    have keys_f: "keys f = {t, t', t''}"
    proof (rule sym, rule card_seteq)
      from less.prems(3, 4) \<open>t'' \<in> keys f\<close> show "{t, t', t''} \<subseteq> keys f" by blast
    next
      from less.prems(5) \<open>t \<noteq> t''\<close> \<open>t' \<noteq> t''\<close> show "card (keys f) \<le> card {t, t', t''}"
        by (simp add: less.prems(2))
    qed (fact finite_keys)
    hence "(\<Sum>s\<in>keys f. monomial (lookup f s) s) = (\<Sum>s\<in>{t, t', t''}. monomial (lookup f s) s)"
      by (simp only:)
    also have "\<dots> = monomial (lookup f t) t + monomial (lookup f t') t' + monomial (lookup f t'') t''"
      using \<open>t \<noteq> t''\<close> \<open>t' \<noteq> t''\<close> less.prems(5) by simp
    finally have f: "f = monomial (lookup f t) t + monomial (lookup f t') t' + monomial (lookup f t'') t''"
      (is "_ = ?f") by (simp only: poly_mapping_sum_monomials)

    define A where "A = {Y. fst Y \<subseteq> keys q1 \<and> snd Y \<subseteq> keys q2 \<and>
                            is_proper_binomial (except q1 (fst Y) * f1 + except q2 (snd Y) * f2) \<and>
                            t \<in> keys (except q1 (fst Y) * f1 + except q2 (snd Y) * f2)}"

    have "A \<noteq> {}"
    proof -
      from less.prems(3) have "t \<in> keys (q1 * f1 + q2 * f2)" by (simp only: less.prems(1))
      also have "\<dots> \<subseteq> keys (q1 * f1) \<union> keys (q2 * f2)" by (rule keys_add_subset)
      finally show ?thesis
      proof
        assume "t \<in> keys (q1 * f1)"
        then obtain s s' where 1: "s \<in> keys q1" and "s' \<in> keys f1" and "t = s + s'"
          by (rule in_keys_timesE)
        from this(3, 2) have "t \<in> (+) s ` keys f1" by (rule image_eqI)
        also from \<open>s \<in> keys q1\<close> have "\<dots> = keys (punit.monom_mult (lookup q1 s) s f1)"
          by (simp add: punit.keys_monom_mult)
        finally have "(keys q1 - {s}, keys q2) \<in> A"
          by (auto simp: A_def 1 times_monomial_left except_Diff_singleton
                    intro!: punit.is_proper_binomial_monom_mult f1_pbinomial)
        thus ?thesis by blast
      next
        assume "t \<in> keys (q2 * f2)"
        then obtain s s' where 1: "s \<in> keys q2" and "s' \<in> keys f2" and "t = s + s'"
          by (rule in_keys_timesE)
        from this(3, 2) have "t \<in> (+) s ` keys f2" by (rule image_eqI)
        also from \<open>s \<in> keys q2\<close> have "\<dots> = keys (punit.monom_mult (lookup q2 s) s f2)"
          by (simp add: punit.keys_monom_mult)
        finally have "(keys q1, keys q2 - {s}) \<in> A"
          by (auto simp: A_def 1 times_monomial_left except_Diff_singleton
                    intro!: punit.is_proper_binomial_monom_mult f2_pbinomial)
        thus ?thesis by blast
      qed
    qed
    obtain Y where "Y \<in> A"
      and Y_min: "\<And>Y0. Y0 \<in> A \<Longrightarrow> card (fst Y) + card (snd Y) \<le> card (fst Y0) + card (snd Y0)"
    proof -
      define l where "l = (LEAST x. x \<in> (\<lambda>Y. card (fst Y) + card (snd Y)) ` A)"
      from \<open>A \<noteq> {}\<close> have "\<exists>x. x \<in> (\<lambda>Y. card (fst Y) + card (snd Y)) ` A" by blast
      hence "l \<in> (\<lambda>Y. card (fst Y) + card (snd Y)) ` A" unfolding l_def by (rule LeastI_ex)
      then obtain Y where "Y \<in> A" and l: "l = card (fst Y) + card (snd Y)" ..
      from this(1) show ?thesis
      proof
        fix Y0
        assume "Y0 \<in> A"
        hence "card (fst Y0) + card (snd Y0) \<in> (\<lambda>Y. card (fst Y) + card (snd Y)) ` A" by (rule imageI)
        thus "card (fst Y) + card (snd Y) \<le> card (fst Y0) + card (snd Y0)"
          unfolding l[symmetric] l_def by (rule Least_le)
      qed
    qed
    define h where "h = except q1 (fst Y) * f1 + except q2 (snd Y) * f2"
    with \<open>Y \<in> A\<close> have "is_proper_binomial h" and "t \<in> keys h" by (simp_all add: A_def)

    show ?case
    proof (cases "t' \<in> keys h")
      case True
      with \<open>is_proper_binomial h\<close> \<open>t \<in> keys h\<close> have h: "h = binomial (lookup h t) t (lookup h t') t'"
        using less.prems(5) by (rule is_proper_binomial_eq_binomial)
      define c where "c = lookup f t / lookup h t"
      show ?thesis
      proof (rule less.prems)
        from less.prems(3) \<open>t \<in> keys h\<close> True show "c * lookup h t' \<noteq> 0" by (simp add: c_def)

        have "keys (except q1 (fst Y)) \<subseteq> keys q1" by (auto simp: keys_except)
        with keys_scalar_subset show "keys (c \<cdot> (except q1 (fst Y))) \<subseteq> keys q1" (is "keys ?q1 \<subseteq> _")
          by (rule subset_trans)

        have "keys (except q2 (snd Y)) \<subseteq> keys q2" by (auto simp: keys_except)
        with keys_scalar_subset show "keys (c \<cdot> (except q2 (snd Y))) \<subseteq> keys q2" (is "keys ?q2 \<subseteq> _")
          by (rule subset_trans)

        have "?q1 * f1 + ?q2 * f2 = c \<cdot> h" by (simp add: h_def scalar_eq_times algebra_simps)
        also have "\<dots> = c \<cdot> (binomial (lookup h t) t (lookup h t') t')" by (subst h) (fact refl)
        also from \<open>t \<in> keys h\<close> have "\<dots> = binomial (lookup f t) t (c * lookup h t') t'"
          by (simp add: scalar_binomial c_def)
        finally show "?q1 * f1 + ?q2 * f2 = binomial (lookup f t) t (c * lookup h t') t'" .
      qed
    next
      case False
      define B where "B = {Y'. fst Y' \<subseteq> keys q1 \<and> snd Y' \<subseteq> keys q2 \<and>
                            keys q1 \<subseteq> fst Y \<union> fst Y' \<and> keys q2 \<subseteq> snd Y \<union> snd Y' \<and>
                            is_proper_binomial (except q1 (fst Y') * f1 + except q2 (snd Y') * f2) \<and>
                            t' \<in> keys (except q1 (fst Y') * f1 + except q2 (snd Y') * f2)}"

      have "B \<noteq> {}"
      proof -
        from less.prems(4) False have "t' \<in> keys (f - h)"
          by (simp add: lookup_minus flip: lookup_not_eq_zero_eq_in_keys)
        have "f - h = (q1 - except q1 (fst Y)) * f1 + (q2 - except q2 (snd Y)) * f2"
          by (simp add: less.prems(1) h_def algebra_simps)
        also have "\<dots> = except q1 (keys q1 - fst Y) * f1 + except q2 (keys q2 - snd Y) * f2"
          by (simp only: except_keys_Diff except_Compl)
        finally have "t' \<in> keys (except q1 (keys q1 - fst Y) * f1 + except q2 (keys q2 - snd Y) * f2)"
          using \<open>t' \<in> keys (f - h)\<close> by (simp only:)
        also have "\<dots> \<subseteq> keys (except q1 (keys q1 - fst Y) * f1) \<union> keys (except q2 (keys q2 - snd Y) * f2)"
          by (rule keys_add_subset)
        finally show ?thesis
        proof
          let ?q = "except q1 (keys q1 - fst Y)"
          assume "t' \<in> keys (?q * f1)"
          then obtain s s' where 1: "s \<in> keys ?q" and "s' \<in> keys f1" and "t' = s + s'"
            by (rule in_keys_timesE)
          from this(1) have "s \<in> keys q1" and "s \<in> fst Y" by (auto simp: keys_except)
          from \<open>t' = s + s'\<close> \<open>s' \<in> keys f1\<close> have "t' \<in> (+) s ` keys f1" by (rule image_eqI)
          also from \<open>s \<in> keys q1\<close> have "\<dots> = keys (punit.monom_mult (lookup q1 s) s f1)"
            by (simp add: punit.keys_monom_mult)
          finally have "(keys q1 - {s}, keys q2) \<in> B" using \<open>s \<in> fst Y\<close>
            by (auto simp: B_def 1 times_monomial_left except_Diff_singleton
                      intro!: punit.is_proper_binomial_monom_mult f1_pbinomial)
          thus ?thesis by blast
        next
          let ?q = "except q2 (keys q2 - snd Y)"
          assume "t' \<in> keys (?q * f2)"
          then obtain s s' where 1: "s \<in> keys ?q" and "s' \<in> keys f2" and "t' = s + s'"
            by (rule in_keys_timesE)
          from this(1) have "s \<in> keys q2" and "s \<in> snd Y" by (auto simp: keys_except)
          from \<open>t' = s + s'\<close> \<open>s' \<in> keys f2\<close> have "t' \<in> (+) s ` keys f2" by (rule image_eqI)
          also from \<open>s \<in> keys q2\<close> have "\<dots> = keys (punit.monom_mult (lookup q2 s) s f2)"
            by (simp add: punit.keys_monom_mult)
          finally have "(keys q1, keys q2 - {s}) \<in> B" using \<open>s \<in> snd Y\<close>
            by (auto simp: B_def 1 times_monomial_left except_Diff_singleton
                      intro!: punit.is_proper_binomial_monom_mult f2_pbinomial)
          thus ?thesis by blast
        qed
      qed
      obtain Y' where "Y' \<in> B"
        and Y'_min: "\<And>Y0. Y0 \<in> B \<Longrightarrow> card (fst Y') + card (snd Y') \<le> card (fst Y0) + card (snd Y0)"
      proof -
        define l where "l = (LEAST x. x \<in> (\<lambda>Y. card (fst Y) + card (snd Y)) ` B)"
        from \<open>B \<noteq> {}\<close> have "\<exists>x. x \<in> (\<lambda>Y. card (fst Y) + card (snd Y)) ` B" by blast
        hence "l \<in> (\<lambda>Y. card (fst Y) + card (snd Y)) ` B" unfolding l_def by (rule LeastI_ex)
        then obtain Y' where "Y' \<in> B" and l: "l = card (fst Y') + card (snd Y')" ..
        from this(1) show ?thesis
        proof
          fix Y0
          assume "Y0 \<in> B"
          hence "card (fst Y0) + card (snd Y0) \<in> (\<lambda>Y. card (fst Y) + card (snd Y)) ` B" by (rule imageI)
          thus "card (fst Y') + card (snd Y') \<le> card (fst Y0) + card (snd Y0)"
            unfolding l[symmetric] l_def by (rule Least_le)
        qed
      qed
      from this(1) have "keys q1 \<subseteq> fst Y \<union> fst Y'" and "keys q2 \<subseteq> snd Y \<union> snd Y'" by (simp_all add: B_def)
      define h' where "h' = except q1 (fst Y') * f1 + except q2 (snd Y') * f2"
      with \<open>Y' \<in> B\<close> have "is_proper_binomial h'" and "t' \<in> keys h'" by (simp_all add: B_def)
      from \<open>is_proper_binomial h\<close> \<open>t \<in> keys h\<close> obtain l where "t \<noteq> l" and keys_h: "keys h = {t, l}"
        by (rule is_proper_binomial_keysE_1)
      from this(2) have "t \<in> keys h" and "l \<in> keys h" by simp_all
      with \<open>is_proper_binomial h\<close> have h: "h = binomial (lookup h t) t (lookup h l) l"
        using \<open>t \<noteq> l\<close> by (rule is_proper_binomial_eq_binomial)
      from \<open>is_proper_binomial h'\<close> \<open>t' \<in> keys h'\<close> obtain l' where "t' \<noteq> l'" and keys_h': "keys h' = {t', l'}"
        by (rule is_proper_binomial_keysE_1)
      from this(2) have "t' \<in> keys h'" and "l' \<in> keys h'" by simp_all
      with \<open>is_proper_binomial h'\<close> have h': "h' = binomial (lookup h' t') t' (lookup h' l') l'"
        using \<open>t' \<noteq> l'\<close> by (rule is_proper_binomial_eq_binomial)
      show ?thesis
      proof (cases "l = t''")
        case True
        define c0 where "c0 = lookup f t'' / lookup h t''"
        define c where "c = (lookup f t * lookup f t') / (lookup f t - c0 * lookup h t)"
        have "c0 \<cdot> h = c0 \<cdot> (binomial (lookup h t) t (lookup h l) l)" by (simp only: h[symmetric])
        also from \<open>l \<in> keys h\<close> have "\<dots> = binomial (c0 * lookup h t) t (lookup f t'') t''"
          by (simp add: scalar_binomial \<open>l = t''\<close> c0_def)
        finally have "f - c0 \<cdot> h = ?f - binomial (c0 * lookup h t) t (lookup f t'') t''"
          by (simp only: f[symmetric])
        also have "\<dots> = binomial (lookup f t') t' (lookup f t - c0 * lookup h t) t"
          by (simp add: binomial_def single_diff)
        finally have 1: "f - c0 \<cdot> h = binomial (lookup f t') t' (lookup f t - c0 * lookup h t) t" .
        have 2: "lookup f t - c0 * lookup h t \<noteq> 0"
        proof
          assume "lookup f t - c0 * lookup h t = 0"
          moreover have "f - c0 \<cdot> h \<in> ideal {f1, f2}"
            by (simp add: ideal.span_diff less.prems(1) in_idealI_2 scalar_eq_times
                ideal.span_scale h_def)
          ultimately have "monomial (lookup f t') t' \<in> ideal {f1, f2}" by (simp add: 1 binomial_def)
          hence "(1 / lookup f t') \<cdot> (monomial (lookup f t') t') \<in> ideal {f1, f2}"
            by (simp add: ideal.span_scale scalar_eq_times)
          with \<open>t' \<in> keys f\<close> have "monomial 1 t' \<in> ideal {f1, f2}"
            by (simp flip: lookup_not_eq_zero_eq_in_keys)
          with less.prems(7) show False ..
        qed
        with less.prems(3, 4) have "c \<noteq> 0" by (simp add: c_def)
        define q1' where "q1' = (c / lookup f t') \<cdot> (q1 - c0 \<cdot> (except q1 (fst Y)))"
        define q2' where "q2' = (c / lookup f t') \<cdot> (q2 - c0 \<cdot> (except q2 (snd Y)))"
        show ?thesis
        proof (rule less.prems)
          have "keys q1' \<subseteq> keys (q1 - c0 \<cdot> (except q1 (fst Y)))" by (simp only: q1'_def keys_scalar_subset)
          also have "\<dots> \<subseteq> keys q1 \<union> keys (c0 \<cdot> (except q1 (fst Y)))" by (fact keys_minus)
          also have "\<dots> \<subseteq> keys q1 \<union> keys (except q1 (fst Y))"
            by (meson keys_scalar_subset subset_refl sup.mono)
          finally show "keys q1' \<subseteq> keys q1" by (auto simp: keys_except)
        next
          have "keys q2' \<subseteq> keys (q2 - c0 \<cdot> (except q2 (snd Y)))" by (simp only: q2'_def keys_scalar_subset)
          also have "\<dots> \<subseteq> keys q2 \<union> keys (c0 \<cdot> (except q2 (snd Y)))" by (fact keys_minus)
          also have "\<dots> \<subseteq> keys q2 \<union> keys (except q2 (snd Y))"
            by (meson keys_scalar_subset subset_refl sup.mono)
          finally show "keys q2' \<subseteq> keys q2" by (auto simp: keys_except)
        next
          have "q1' * f1 + q2' * f2 = (c / lookup f t') \<cdot> (f - c0 \<cdot> h)"
            by (simp add: q1'_def q2'_def h_def less.prems(1) algebra_simps scalar_eq_times)
          also from 2 less.prems(4) have "\<dots> = binomial c t' (lookup f t) t"
            by (simp add: 1 scalar_binomial c_def)
          finally show "q1' * f1 + q2' * f2 = binomial (lookup f t) t c t'" by (simp only: binomial_comm)
        qed fact
      next
        case False
        show ?thesis
        proof (cases "l' = t''")
          case True
          define c0 where "c0 = lookup f t'' / lookup h' t''"
          define c where "c = lookup f t' - c0 * lookup h' t'"
          have "c0 \<cdot> h' = c0 \<cdot> (binomial (lookup h' t') t' (lookup h' l') l')" by (simp only: h'[symmetric])
          also from \<open>l' \<in> keys h'\<close> have "\<dots> = binomial (c0 * lookup h' t') t' (lookup f t'') t''"
            by (simp add: scalar_binomial \<open>l' = t''\<close> c0_def)
          finally have "f - c0 \<cdot> h' = ?f - binomial (c0 * lookup h' t') t' (lookup f t'') t''"
            by (simp only: f[symmetric])
          also have "\<dots> = binomial (lookup f t) t c t'" by (simp add: binomial_def single_diff c_def)
          finally have 1: "f - c0 \<cdot> h' = binomial (lookup f t) t c t'" .
          define q1' where "q1' = q1 - c0 \<cdot> except q1 (fst Y')"
          define q2' where "q2' = q2 - c0 \<cdot> except q2 (snd Y')"
          show ?thesis
          proof (rule less.prems)
            show "c \<noteq> 0"
            proof
              assume "c = 0"
              moreover have "f - c0 \<cdot> h' \<in> ideal {f1, f2}"
                by (simp add: ideal.span_diff less.prems(1) in_idealI_2 scalar_eq_times
                    ideal.span_scale h'_def)
              ultimately have "monomial (lookup f t) t \<in> ideal {f1, f2}" by (simp add: 1 binomial_def)
              hence "(1 / lookup f t) \<cdot> (monomial (lookup f t) t) \<in> ideal {f1, f2}"
                by (simp add: ideal.span_scale scalar_eq_times)
              with \<open>t \<in> keys f\<close> have "monomial 1 t \<in> ideal {f1, f2}"
                by (simp flip: lookup_not_eq_zero_eq_in_keys)
              with less.prems(6) show False ..
            qed
          next
            have "keys q1' \<subseteq> keys q1 \<union> keys (c0 \<cdot> except q1 (fst Y'))"
              by (simp add: q1'_def keys_minus)
            also have "\<dots> \<subseteq> keys q1 \<union> keys (except q1 (fst Y'))"
              by (meson keys_scalar_subset subset_refl sup.mono)
            finally show "keys q1' \<subseteq> keys q1" by (auto simp: keys_except)
          next
            have "keys q2' \<subseteq> keys q2 \<union> keys (c0 \<cdot> except q2 (snd Y'))"
              by (simp add: q2'_def keys_minus)
            also have "\<dots> \<subseteq> keys q2 \<union> keys (except q2 (snd Y'))"
              by (meson keys_scalar_subset subset_refl sup.mono)
            finally show "keys q2' \<subseteq> keys q2" by (auto simp: keys_except)
          next
            show "q1' * f1 + q2' * f2 = binomial (lookup f t) t c t'" unfolding 1[symmetric]
              by (simp add: q1'_def q2'_def h'_def less.prems(1) algebra_simps scalar_eq_times)
          qed
        next
          case False
          show ?thesis
          proof (cases "l' = t")
            case True
            with \<open>l' \<in> keys h'\<close> have "t \<in> keys h'" by simp
            define c0 where "c0 = lookup f t / lookup h' t"
            define c where "c = c0 * lookup h' t'"
            show ?thesis
            proof (rule less.prems)
              from less.prems(3) \<open>t \<in> keys h'\<close> \<open>t' \<in> keys h'\<close> show "c \<noteq> 0"
                by (simp add: c_def c0_def)
            next
              show "keys (c0 \<cdot> except q1 (fst Y')) \<subseteq> keys q1"
                by (simp add: keys_except keys_scalar)
            next
              show "keys (c0 \<cdot> except q2 (snd Y')) \<subseteq> keys q2"
                by (simp add: keys_except keys_scalar)
            next
              have "c0 \<cdot> except q1 (fst Y') * f1 + c0 \<cdot> except q2 (snd Y') * f2 = c0 \<cdot> h'"
                by (simp add: h'_def algebra_simps scalar_eq_times)
              also have "\<dots> = c0 \<cdot> (binomial (lookup h' t') t' (lookup h' t) t)"
                by (simp flip: \<open>l' = t\<close> h')
              also from \<open>t \<in> keys h'\<close> have "\<dots> = binomial c t' (lookup f t) t"
                by (simp add: scalar_binomial c_def c0_def)
              finally show "c0 \<cdot> except q1 (fst Y') * f1 + c0 \<cdot> except q2 (snd Y') * f2 =
                            binomial (lookup f t) t c t'" by (simp only: binomial_comm)
            qed
          next
            case False
            show ?thesis
            proof (cases "l = l'")
              case True
              define c0 where "c0 = lookup f t / lookup h t"
              define c1 where "c1 = lookup h l / lookup h' l"
              define c where "c = - c0 * c1 * lookup h' t'"
              define q1' where "q1' = c0 \<cdot> (except q1 (fst Y) - c1 \<cdot> except q1 (fst Y'))"
              define q2' where "q2' = c0 \<cdot> (except q2 (snd Y) - c1 \<cdot> except q2 (snd Y'))"
              show ?thesis
              proof (rule less.prems)
                show "c \<noteq> 0" using less.prems(3) \<open>l' \<in> keys h'\<close> \<open>t' \<in> keys h'\<close> \<open>t \<in> keys h\<close> \<open>l \<in> keys h\<close>
                  by (simp add: c_def c0_def c1_def True)
              next
                have "keys q1' \<subseteq> keys (except q1 (fst Y) - c1 \<cdot> except q1 (fst Y'))"
                  unfolding q1'_def by (fact keys_scalar_subset)
                also have "\<dots> \<subseteq> keys (except q1 (fst Y)) \<union> keys (c1 \<cdot> except q1 (fst Y'))"
                  by (rule keys_minus)
                also have "\<dots> \<subseteq> keys (except q1 (fst Y)) \<union> keys (except q1 (fst Y'))"
                  by (meson keys_scalar_subset subset_refl sup.mono)
                finally show "keys q1' \<subseteq> keys q1" by (auto simp: keys_except)
              next
                have "keys q2' \<subseteq> keys (except q2 (snd Y) - c1 \<cdot> except q2 (snd Y'))"
                  unfolding q2'_def by (fact keys_scalar_subset)
                also have "\<dots> \<subseteq> keys (except q2 (snd Y)) \<union> keys (c1 \<cdot> except q2 (snd Y'))"
                  by (rule keys_minus)
                also have "\<dots> \<subseteq> keys (except q2 (snd Y)) \<union> keys (except q2 (snd Y'))"
                  by (meson keys_scalar_subset subset_refl sup.mono)
                finally show "keys q2' \<subseteq> keys q2" by (auto simp: keys_except)
              next
                have "q1' * f1 + q2' * f2 = c0 \<cdot> (h - c1 \<cdot> h')"
                  by (simp add: q1'_def q2'_def scalar_eq_times algebra_simps h_def h'_def)
                also have "\<dots> = c0 \<cdot> (binomial (lookup h t) t (lookup h l) l -
                                      c1 \<cdot> binomial (lookup h' t') t' (lookup h' l') l')"
                  by (simp only: flip: h h')
                also from \<open>l' \<in> keys h'\<close> \<open>t \<in> keys h\<close> have "\<dots> = binomial (lookup f t) t c t'"
                  by (simp add: binomial_def c_def \<open>l = l'\<close> algebra_simps c0_def c1_def flip: single_add)
                finally show "q1' * f1 + q2' * f2 = binomial (lookup f t) t c t'" .
              qed
            next
              case False
              from \<open>l \<in> keys h\<close> \<open>t' \<notin> keys h\<close> have "l \<noteq> t'" by blast
              with \<open>t \<noteq> l\<close> \<open>l \<noteq> t''\<close> have "l \<notin> keys f" by (simp add: keys_f)
              from \<open>l' \<noteq> t\<close> \<open>t' \<noteq> l'\<close> \<open>l' \<noteq> t''\<close> have "l' \<notin> keys f" by (simp add: keys_f)
              from \<open>t \<noteq> t''\<close> \<open>l \<noteq> t''\<close> have "t'' \<notin> keys h" by (simp add: keys_h)
              from \<open>l \<noteq> l'\<close> \<open>l' \<noteq> t\<close> have "l' \<notin> keys h" by (simp add: keys_h)
              from \<open>t' \<noteq> t''\<close> \<open>l' \<noteq> t''\<close> have "t'' \<notin> keys h'" by (simp add: keys_h')
              from \<open>l \<noteq> l'\<close> \<open>l \<noteq> t'\<close> have "l \<notin> keys h'" by (simp add: keys_h')
              define d where "d = lookup f t / lookup h t"
              define d' where "d' = lookup f t' / lookup h' t'"
              define h'' where "h'' = f - h - h'"
              from less.prems(3) \<open>t \<in> keys h\<close> have "d \<noteq> 0" by (simp add: d_def)
              from less.prems(4) \<open>t' \<in> keys h'\<close> have "d' \<noteq> 0" by (simp add: d'_def)
              have "keys h'' = {t'', l, l'}"
              proof
                (* ERROR: Could be that "t \<in> keys h''" or "t' \<in> keys h''", or both. *)
                show "keys h'' \<subseteq> {t'', l, l'}" sorry
              next
                from \<open>l \<notin> keys h'\<close> \<open>l \<notin> keys f\<close> have "lookup h'' l = - lookup h l"
                  by (simp add: h''_def lookup_minus)
                also from \<open>l \<in> keys h\<close> \<open>d \<noteq> 0\<close> have "\<dots> \<noteq> 0" by simp
                finally have l: "l \<in> keys h''" by simp
                from \<open>l' \<notin> keys f\<close> \<open>l' \<notin> keys h\<close> have "lookup h'' l' = - lookup h' l'"
                  by (simp add: h''_def lookup_minus)
                also from \<open>l' \<in> keys h'\<close> \<open>d' \<noteq> 0\<close> have "\<dots> \<noteq> 0" by simp
                finally have l': "l' \<in> keys h''" by simp
                from \<open>t'' \<notin> keys h\<close> \<open>t'' \<notin> keys h'\<close> have "lookup h'' t'' = lookup f t''"
                  by (simp add: h''_def lookup_minus)
                also from \<open>t'' \<in> keys f\<close> have "\<dots> \<noteq> 0" by simp
                finally have "t'' \<in> keys h''" by simp
                with l l' show "{t'', l, l'} \<subseteq> keys h''" by blast
              qed
              with \<open>l \<noteq> t''\<close> \<open>l \<noteq> l'\<close> \<open>l' \<noteq> t''\<close> have "card (keys h'') = 3" by simp
              define q1'' where "q1'' = except q1 (keys q1 - (fst Y \<inter> fst Y'))"
              define q2'' where "q2'' = except q2 (keys q2 - (snd Y \<inter> snd Y'))"
              have "q1'' = q1 - except q1 (fst Y \<inter> fst Y')"
                by (simp only: q1''_def except_keys_Diff except_Compl)
              also have "except q1 (fst Y \<inter> fst Y') = except q1 (fst Y) + except q1 (fst Y')"
                using \<open>keys q1 \<subseteq> fst Y \<union> fst Y'\<close> by (rule except_Int)
              finally have q1'': "q1'' = q1 - except q1 (fst Y) - except q1 (fst Y')" by simp
              have "q2'' = q2 - except q2 (snd Y \<inter> snd Y')"
                by (simp only: q2''_def except_keys_Diff except_Compl)
              also have "except q2 (snd Y \<inter> snd Y') = except q2 (snd Y) + except q2 (snd Y')"
                using \<open>keys q2 \<subseteq> snd Y \<union> snd Y'\<close> by (rule except_Int)
              finally have q2'': "q2'' = q2 - except q2 (snd Y) - except q2 (snd Y')" by simp
              have "h'' = q1'' * f1 + q2'' * f2"
                by (simp add: q1'' q2'' h''_def less.prems(1) h_def h'_def algebra_simps)

              thm less.hyps
              then show ?thesis sorry
            qed
          qed
        qed
      qed
    qed
  qed
qed

definition deg_vpc :: "('x point \<times> 'x point) list \<Rightarrow> rat"
  where "deg_vpc zs = Max (deg_pair ` set zs)"

definition is_min_vpc :: "('x point \<times> 'x point) list \<Rightarrow> bool"
  where "is_min_vpc zs \<longleftrightarrow> is_vpc zs \<and>
                   (\<forall>zs'. is_vpc zs' \<longrightarrow> fst (hd zs') = fst (hd zs) \<longrightarrow> snd (last zs') = snd (last zs) \<longrightarrow>
                          length zs < length zs' \<or> (length zs = length zs' \<and> deg_vpc zs \<le> deg_vpc zs'))"

end

end (* two_polys *)

end (* theory *)
