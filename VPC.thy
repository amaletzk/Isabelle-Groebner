section \<open>Valid Polygonial Chains\<close>

theory VPC
  imports Binomials Binom_Mult
begin

subsection \<open>Preliminaries\<close>

text \<open>Since most results in this theory are concerned with ideals generated by two polynomials, we
  prove some specific properties of such ideals.\<close>

lemma idealI_2: "q1 * f1 + q2 * f2 \<in> ideal {f1, f2::'a::comm_powerprod \<Rightarrow>\<^sub>0 'b::comm_ring_1}"
  by (rule ideal.span_add, rule ideal.span_scale, rule ideal.span_base,
      simp, rule ideal.span_scale, rule ideal.span_base, simp)

lemma idealE_2:
  assumes "f \<in> ideal {f1, f2}"
  obtains q1 q2 where "f = q1 * f1 + q2 * f2"
  using assms
proof (induct f arbitrary: thesis rule: ideal.span_induct')
  case base
  show ?case
  proof (rule base)
    show "0 = 0 * f1 + 0 * f2" by simp
  qed
next
  case (step f' c g)
  obtain q1 q2 where f'_eq: "f' = q1 * f1 + q2 * f2" by (rule step(2))
  from step(3) have "g = f1 \<or> g = f2" by simp
  thus ?case
  proof
    assume "g = f1"
    show ?case
    proof (rule step(5))
      show "f' + c * g = (q1 + c) * f1 + q2 * f2" by (simp add: f'_eq \<open>g = f1\<close> algebra_simps)
    qed
  next
    assume "g = f2"
    show ?case
    proof (rule step(5))
      show "f' + c * g = q1 * f1 + (q2 + c) * f2" by (simp add: f'_eq \<open>g = f2\<close> algebra_simps)
    qed
  qed
qed

lemma ideal_iff_2:
  "f \<in> ideal {f1, f2} \<longleftrightarrow> (\<exists>q1 q2. f = q1 * f1 + q2 * (f2::'a::comm_powerprod \<Rightarrow>\<^sub>0 'b::comm_ring_1))"
proof
  assume "f \<in> ideal {f1, f2}"
  then obtain q1 q2 where "f = q1 * f1 + q2 * f2" by (rule idealE_2)
  show "\<exists>q1 q2. f = q1 * f1 + q2 * f2" by (intro exI, fact)
next
  assume "\<exists>q1 q2. f = q1 * f1 + q2 * f2"
  then obtain q1 q2 where f_eq: "f = q1 * f1 + q2 * f2" by auto
  show "f \<in> ideal {f1, f2}" unfolding f_eq by (rule idealI_2)
qed

lemma map_scale_binomial:
  "a \<cdot> binomial c s d t = binomial (a * c) s (a * (d::_::semiring_0)) (t::_::comm_powerprod)"
  by (simp add: punit.map_scale_eq_monom_mult punit.monom_mult_binomial)

definition is_nat_pm_pair :: "(('x \<Rightarrow>\<^sub>0 'b) * ('x \<Rightarrow>\<^sub>0 'b::floor_ceiling)) \<Rightarrow> bool" where
  "is_nat_pm_pair pp = (is_nat_pm (fst pp) \<and> is_nat_pm (snd pp))"

definition is_int_pm_pair :: "(('x \<Rightarrow>\<^sub>0 'b) * ('x \<Rightarrow>\<^sub>0 'b::floor_ceiling)) \<Rightarrow> bool" where
  "is_int_pm_pair pp = (is_int_pm (fst pp) \<and> is_int_pm (snd pp))"
  
lemma is_nat_pm_pairI: "is_nat_pm (fst pp) \<Longrightarrow> is_nat_pm (snd pp) \<Longrightarrow> is_nat_pm_pair pp"
  unfolding is_nat_pm_pair_def ..
    
lemma is_nat_pm_pairD:
  assumes "is_nat_pm_pair pp"
  shows "is_nat_pm (fst pp)" and "is_nat_pm (snd pp)"
  using assms by (simp_all add: is_nat_pm_pair_def)

lemma is_nat_pm_pair_swap [iff]: "is_nat_pm_pair (prod.swap pp) \<longleftrightarrow> is_nat_pm_pair pp"
  by (auto simp: is_nat_pm_pair_def)

lemma is_int_pm_pairI: "is_int_pm (fst pp) \<Longrightarrow> is_int_pm (snd pp) \<Longrightarrow> is_int_pm_pair pp"
  unfolding is_int_pm_pair_def ..
    
lemma is_int_pm_pairD:
  assumes "is_int_pm_pair pp"
  shows "is_int_pm (fst pp)" and "is_int_pm (snd pp)"
  using assms by (simp_all add: is_int_pm_pair_def)
    
lemma nat_pm_pair_is_int_pm_pair: "is_nat_pm_pair pp \<Longrightarrow> is_int_pm_pair pp"
  by (auto intro: is_int_pm_pairI dest: is_nat_pm_pairD nat_pm_is_int_pm)

abbreviation "rat \<equiv> rat_of_nat"

type_synonym 'x point = "('x \<Rightarrow>\<^sub>0 rat)"

context pm_powerprod
begin

lemma binomial_lp_in_ideal_iff:
  assumes "f \<in> ideal F" and "is_binomial f"
  shows "monomial 1 (lp f) \<in> ideal F \<longleftrightarrow> monomial (1::_::field) (tp f) \<in> ideal F"
proof (cases "is_monomial f")
  case True
  hence "lp f = tp f" by (rule punit.lt_eq_tt_monomial)
  thus ?thesis by simp
next
  case False
  with assms(2) have "is_proper_binomial f" by (simp add: is_binomial_alt)
  hence "tp f \<prec> lp f" by (rule punit.lt_gr_tt_binomial)
  hence "lp f \<noteq> tp f" by simp
  from assms(2) have "keys f = {lp f, tp f}" by (rule punit.keys_binomial)
  moreover have "monomial 1 u \<in> ideal F" if "monomial 1 v \<in> ideal F" and "keys f = {u, v}" for u v
  proof -
    from \<open>keys f = {lp f, tp f}\<close> that(2) \<open>lp f \<noteq> tp f\<close> have "u \<noteq> v" by auto
    hence "monomial (lookup f u) u + monomial (lookup f v) v = f"
      by (auto intro!: poly_mapping_eqI simp: lookup_add lookup_single when_def \<open>keys f = {u, v}\<close>)
    moreover define c where "c = lookup f u"
    moreover define d where "d = lookup f v"
    ultimately have f: "f = monomial c u + punit.monom_mult d 0 (monomial 1 v)"
      by (simp add: punit.monom_mult_monomial)
    from that(1) have "punit.monom_mult d 0 (monomial 1 v) \<in> ideal F"
      by (rule punit.pmdl_closed_monom_mult[simplified])
    with assms(1) have "f - punit.monom_mult d 0 (monomial 1 v) \<in> ideal F" by (rule ideal.span_diff)
    hence "monomial c u \<in> ideal F" by (simp add: f)
    hence "punit.monom_mult (1 / c) 0 (monomial c u) \<in> ideal F"
      by (rule punit.pmdl_closed_monom_mult[simplified])
    moreover have "c \<noteq> 0" by (simp add: c_def \<open>keys f = {u, v}\<close>)
    ultimately show ?thesis by (simp add: punit.monom_mult_monomial)
  qed
  ultimately show ?thesis by blast
qed

lemma lem_3_3_12:
  assumes "f \<in> ideal F" and "f' \<in> ideal F" and "is_proper_binomial f" and "monomial 1 (tp f) \<notin> ideal F"
    and "keys f = keys f'"
  obtains c where "c \<noteq> (0::_::field)" and "f = punit.monom_mult c 0 f'"
proof -
  define c where "c = lc f / lc f'"
  from assms(3, 5) have f'_pbinomial: "is_proper_binomial f'" by (simp only: is_proper_binomial_def)
  hence "f' \<noteq> 0" by (rule proper_binomial_not_0)
  hence "lc f' \<noteq> 0" by (rule punit.lc_not_0)
  hence eq1: "c * lc f' = lc f" by (simp add: c_def)
  from f'_pbinomial have "binomial (lc f') (lp f') (tc f') (tp f') = f'" by (rule punit.binomial_eq_itself)
  moreover from assms(5) have "lp f' = lp f"
    by (metis lookup_zero not_in_keys_iff_lookup_eq_zero punit.lt_def punit.lt_in_keys)
  moreover from assms(5) have "tp f' = tp f"
    by (metis lookup_zero not_in_keys_iff_lookup_eq_zero punit.tt_def punit.tt_in_keys)
  ultimately have f': "binomial (lc f') (lp f) (tc f') (tp f) = f'" by simp
  also note assms(2)
  finally have "monomial c 0 * binomial (lc f') (lp f) (tc f') (tp f) \<in> ideal F"
    by (rule ideal.span_scale)
  with \<open>lc f' \<noteq> 0\<close> have 1: "binomial (lc f) (lp f) (c * tc f') (tp f) \<in> ideal F"
    by (simp add: times_monomial_left punit.monom_mult_binomial c_def)
  from assms(3) have "binomial (lc f) (lp f) (tc f) (tp f) = f" by (rule punit.binomial_eq_itself)
  also note assms(1)
  finally have "binomial (lc f) (lp f) (tc f) (tp f) - binomial (lc f) (lp f) (c * tc f') (tp f) \<in> ideal F"
    using 1 by (rule ideal.span_diff)
  hence 2: "monomial (tc f - c * tc f') (tp f) \<in> ideal F" by (simp add: binomial_def single_diff)
  have eq2: "c * tc f' = tc f"
  proof (rule ccontr)
    assume "c * tc f' \<noteq> tc f"
    hence "tc f - c * tc f' \<noteq> 0" by simp
    moreover from 2 have "monomial (1 / (tc f - c * tc f')) 0 * monomial (tc f - c * tc f') (tp f) \<in> ideal F"
      by (rule ideal.span_scale)
    ultimately have "monomial 1 (tp f) \<in> ideal F" by (simp add: times_monomial_monomial)
    with assms(4) show False ..
  qed
  show ?thesis
  proof
    from assms(3) have "f \<noteq> 0" by (rule proper_binomial_not_0)
    hence "lc f \<noteq> 0" by (rule punit.lc_not_0)
    with \<open>lc f' \<noteq> 0\<close> show "c \<noteq> 0" by (simp add: c_def)
  next
    have "punit.monom_mult c 0 f' = punit.monom_mult c 0 (binomial (lc f') (lp f) (tc f') (tp f))"
      by (simp only: f')
    also have "\<dots> = binomial (lc f) (lp f) (tc f) (tp f)"
      by (simp add: punit.monom_mult_binomial eq1 eq2)
    also have "\<dots> = f" by fact
    finally show "f = punit.monom_mult c 0 f'" by (rule sym)
  qed
qed

lemma map_scale_mono:
  assumes "m \<le> n"
  shows "m \<cdot> t \<preceq> n \<cdot> t"
proof -
  have "m \<cdot> t \<preceq> m \<cdot> t + (n - m) \<cdot> t" using zero_min plus_monotone_left by fastforce
  also have "\<dots> = (m + (n - m)) \<cdot> t" by (simp only: map_scale_distrib_right)
  also from assms have "\<dots> = n \<cdot> t" by simp
  finally show ?thesis .
qed

lemma map_scale_mono_left:
  assumes "s \<preceq> t"
  shows "m \<cdot> s \<preceq> m \<cdot> t"
proof (induct m)
  case 0
  show ?case by simp
next
  case (Suc m)
  have "Suc m \<cdot> s = (m + 1) \<cdot> s" by simp
  also have "\<dots> = m \<cdot> s + s" by (simp only: map_scale_distrib_right map_scale_one_left)
  also from Suc have "\<dots> \<preceq> m \<cdot> t + s" by (rule plus_monotone)
  also from assms have "\<dots> \<preceq> m \<cdot> t + t" by (rule plus_monotone_left)
  also have "\<dots> = (m + 1) \<cdot> t" by (simp only: map_scale_distrib_right map_scale_one_left)
  also have "\<dots> = Suc m \<cdot> t" by simp
  finally show ?case .
qed

lemma map_scale_mono_strict:
  assumes "m < n" and "t \<noteq> 0"
  shows "m \<cdot> t \<prec> n \<cdot> t"
proof -
  from assms(1) have "m \<le> n" by simp
  hence "m \<cdot> t \<preceq> n \<cdot> t" by (rule map_scale_mono)
  moreover have "m \<cdot> t \<noteq> n \<cdot> t"
  proof
    from assms(2) obtain x where "0 < lookup t x" using aux by auto
    assume "m \<cdot> t = n \<cdot> t"
    hence "lookup (m \<cdot> t) x = lookup (n \<cdot> t) x" by simp
    with \<open>0 < lookup t x\<close> assms(1) show False by simp
  qed
  ultimately show ?thesis by simp
qed

lemma map_scale_mono_strict_left:
  assumes "s \<prec> t" and "0 < m"
  shows "m \<cdot> s \<prec> m \<cdot> t"
proof -
  from assms(1) have "s \<preceq> t" by simp
  hence "m \<cdot> s \<preceq> m \<cdot> t" by (rule map_scale_mono_left)
  moreover have "m \<cdot> s \<noteq> m \<cdot> t"
  proof
    from assms(1) have "s \<noteq> t" by simp
    then obtain x where "lookup s x \<noteq> lookup t x" by (meson poly_mapping_eqI)
    with assms(2) have "lookup (m \<cdot> s) x \<noteq> lookup (m \<cdot> t) x" by simp
    moreover assume "m \<cdot> s = m \<cdot> t"
    ultimately show False by simp
  qed
  ultimately show ?thesis by simp
qed

definition poly_point :: "(('x \<Rightarrow>\<^sub>0 nat) \<Rightarrow>\<^sub>0 'b::zero) \<Rightarrow> ('x point \<times> 'x point)" where
  "poly_point p = (of_nat_pm (lp p), of_nat_pm (tp p))"

definition vect :: "(('x \<Rightarrow>\<^sub>0 nat) \<Rightarrow>\<^sub>0 'b::zero) \<Rightarrow> ('x point)"
  where "vect p = fst (poly_point p) - snd (poly_point p)"

lemma fst_poly_point: "fst (poly_point p) = of_nat_pm (lp p)"
  by (simp add: poly_point_def)
    
lemma snd_poly_point: "snd (poly_point p) = of_nat_pm (tp p)"
  by (simp add: poly_point_def)

lemma poly_point_is_nat_pm_pair: "is_nat_pm_pair (poly_point p)"
  unfolding poly_point_def by (rule is_nat_pm_pairI, simp_all, (rule of_nat_pm_is_nat_pm)+)

lemma poly_point_is_int_pm_pair: "is_int_pm_pair (poly_point p)"
  using poly_point_is_nat_pm_pair by (rule nat_pm_pair_is_int_pm_pair)

lemma swap_poly_point_not_eq:
  assumes "is_proper_binomial p"
  shows "prod.swap (poly_point p) \<noteq> poly_point q"
proof
  assume "prod.swap (poly_point p) = poly_point q"
  hence 1: "lp p = tp q" and 2: "tp p = lp q" by (simp_all add: poly_point_def)
  from assms(1) have "tp p \<prec> lp p" by (rule punit.lt_gr_tt_binomial)
  hence "lp q \<prec> tp q" by (simp only: 1 2)
  with punit.lt_ge_tt[of q] show False by simp
qed

corollary swap_poly_point_not_eq':
  assumes "is_proper_binomial q"
  shows "prod.swap (poly_point p) \<noteq> poly_point q"
proof
  assume *: "prod.swap (poly_point p) = poly_point q"
  from assms have "prod.swap (poly_point q) \<noteq> poly_point p" by (rule swap_poly_point_not_eq)
  moreover from *[symmetric] have "prod.swap (poly_point q) = poly_point p" by simp
  ultimately show False ..
qed

lemma fst_eq_snd_poly_point_iff: "fst (poly_point p) = snd (poly_point p) \<longleftrightarrow> card (keys p) \<le> 1"
proof -
  have "fst (poly_point p) = snd (poly_point p) \<longleftrightarrow> lp p = tp p"
    by (simp add: poly_point_def)
  also have "\<dots> \<longleftrightarrow> card (keys p) \<le> 1" by (simp only: punit.lt_eq_tt_iff has_bounded_keys_def)
  finally show ?thesis .
qed

lemma vect_alt: "vect p = of_nat_pm (lp p) - of_nat_pm (tp p)"
  by (simp only: vect_def fst_poly_point snd_poly_point)

lemma vect_is_int_pm: "is_int_pm (vect p)"
  by (simp add: vect_def is_int_pm_pairD[OF poly_point_is_int_pm_pair] is_int_pm_pairD minus_is_int_pm)

end (* pm_powerprod *)

locale two_polys =
  pm_powerprod ord ord_strict
  for ord::"('x \<Rightarrow>\<^sub>0 nat) \<Rightarrow> ('x::{countable,linorder} \<Rightarrow>\<^sub>0 nat) \<Rightarrow> bool" (infixl "\<preceq>" 50)
  and ord_strict (infixl "\<prec>" 50) +
  fixes f1 f2 :: "('x \<Rightarrow>\<^sub>0 nat) \<Rightarrow>\<^sub>0 'b::field"
begin

definition overlap :: "'x point"
  where "overlap = lcs (gcs (fst (poly_point f1)) (snd (poly_point f1)))
                       (gcs (fst (poly_point f2)) (snd (poly_point f2)))"

lemma overlap_alt:
  "overlap = lcs (gcs (of_nat_pm (lp f1)) (of_nat_pm (tp f1)))
                 (gcs (of_nat_pm (lp f2)) (of_nat_pm (tp f2)))"
  by (simp only: overlap_def fst_poly_point snd_poly_point)

lemma overlap_alt': "overlap = of_nat_pm (lcs (gcs (lp f1) (tp f1)) (gcs (lp f2) (tp f2)))"
  by (simp add: overlap_alt gcs_of_nat_pm lcs_of_nat_pm)

lemma overlap_is_nat_pm: "is_nat_pm overlap"
  by (simp add: overlap_def is_nat_pm_pairD[OF poly_point_is_nat_pm_pair] gcs_is_nat_pm lcs_is_nat_pm)

lemma gcs_le_overlap:
  shows "gcs (of_nat_pm (lp f1)) (of_nat_pm (tp f1)) \<unlhd> overlap"
    and "gcs (of_nat_pm (lp f2)) (of_nat_pm (tp f2)) \<unlhd> overlap"
  by (simp_all add: overlap_alt le_pm_def lookup_lcs_fun leq_lcs_fun_1 leq_lcs_fun_2)

lemma gcs_le_overlap':
  shows "of_nat_pm (gcs (lp f1) (tp f1)) \<unlhd> overlap" and "of_nat_pm (gcs (lp f2) (tp f2)) \<unlhd> overlap"
  using gcs_le_overlap by (simp_all add: gcs_of_nat_pm)

lemma overlap_is_int_pm: "is_int_pm overlap"
  using overlap_is_nat_pm by (rule nat_pm_is_int_pm)

lemma lem_3_1_13:
  assumes "of_nat_pm (tp f1) \<unlhd> p" and "of_nat_pm (tp f2) \<unlhd> p"
  shows "overlap \<unlhd> p"
  unfolding overlap_alt lookup_lcs_fun le_pm_def
proof (rule lcs_leq_fun)
  let ?t = "of_nat_pm (lp f1)"
  let ?s = "of_nat_pm (tp f1)"
  have "lookup (gcs ?t ?s) \<le> lookup ?s" unfolding lookup_gcs_fun by (fact gcs_leq_fun_2)
  also from assms(1) have "... \<le> lookup p" by (simp only: le_pm_def)
  finally show "lookup (gcs ?t ?s) \<le> lookup p" .
next
  let ?t = "of_nat_pm (lp f2)"
  let ?s = "of_nat_pm (tp f2)"
  have "lookup (gcs ?t ?s) \<le> lookup ?s" unfolding lookup_gcs_fun by (fact gcs_leq_fun_2)
  also from assms(2) have "... \<le> lookup p" by (simp only: le_pm_def)
  finally show "lookup (gcs ?t ?s) \<le> lookup p" .
qed

subsection \<open>VPCs\<close>

definition shifts :: "('x point \<times> 'x point) set"
  where "shifts = (let A = {poly_point f1, poly_point f2} in A \<union> prod.swap ` A)"

lemma shiftsI1: "s = poly_point f1 \<Longrightarrow> s \<in> shifts"
  by (simp add: shifts_def)

lemma shiftsI2: "s = poly_point f2 \<Longrightarrow> s \<in> shifts"
  by (simp add: shifts_def)

lemma shiftsI3: "s = prod.swap (poly_point f1) \<Longrightarrow> s \<in> shifts"
  by (simp add: shifts_def)

lemma shiftsI4: "s = prod.swap (poly_point f2) \<Longrightarrow> s \<in> shifts"
  by (simp add: shifts_def)

lemma shiftsI:
  assumes "f \<in> {f1, f2}"
  shows "poly_point f \<in> shifts" and "prod.swap (poly_point f) \<in> shifts"
  using assms by (auto intro: shiftsI1 shiftsI2 shiftsI3 shiftsI4)

lemma shifts_cases:
  assumes "s \<in> shifts"
  obtains "s = poly_point f1" | "s = poly_point f2" |
          "s = prod.swap (poly_point f1)" | "s = prod.swap (poly_point f2)"
  using assms by (auto simp: shifts_def)

lemma shifts_cases_poly:
  assumes "s \<in> shifts"
  obtains "s = poly_point f1 \<or> s = prod.swap (poly_point f1)" |
          "s = poly_point f2 \<or> s = prod.swap (poly_point f2)"
  using assms by (auto simp: shifts_def)

lemma image_swap_shifts [simp]: "prod.swap ` shifts = shifts"
  by (auto simp: shifts_def)

lemma shifts_is_nat_pm_pair: "z \<in> shifts \<Longrightarrow> is_nat_pm_pair z"
  by (elim shifts_cases) (simp_all add: poly_point_is_nat_pm_pair)

definition nat_plus_point_pair :: "('x \<Rightarrow>\<^sub>0 nat) \<Rightarrow> ('x point \<times> 'x point) \<Rightarrow> ('x point \<times> 'x point)" (infixl "+\<^sub>N" 70)
  where "nat_plus_point_pair t pp = (of_nat_pm t + fst pp, of_nat_pm t + snd pp)"

lemma swap_nat_plus_point_pair: "prod.swap (t +\<^sub>N pp) = t +\<^sub>N prod.swap pp"
  by (simp add: nat_plus_point_pair_def)

lemma nat_plus_point_pair_is_nat_pm_pair: "is_nat_pm_pair pp \<Longrightarrow> is_nat_pm_pair (t +\<^sub>N pp)"
  by (simp add: nat_plus_point_pair_def is_nat_pm_pair_def plus_is_nat_pm of_nat_pm_is_nat_pm)

lemma nat_plus_point_pair_is_int_pm_pair: "is_int_pm_pair pp \<Longrightarrow> is_int_pm_pair (t +\<^sub>N pp)"
  by (simp add: nat_plus_point_pair_def is_int_pm_pair_def plus_is_int_pm of_nat_pm_is_nat_pm nat_pm_is_int_pm)

lemma nat_plus_point_pair_fst_eq_snd_iff [iff]: "fst (t +\<^sub>N pp) = snd (t +\<^sub>N pp) \<longleftrightarrow> fst pp = snd pp"
  by (auto simp: nat_plus_point_pair_def)

abbreviation "Nshifts \<equiv> case_prod (+\<^sub>N) ` (UNIV \<times> shifts)"

lemma Nshifts_eqI: "z = t +\<^sub>N s \<Longrightarrow> s \<in> shifts \<Longrightarrow> z \<in> Nshifts"
  by blast

lemma NshiftsI: "s \<in> shifts \<Longrightarrow> t +\<^sub>N s \<in> Nshifts"
  by blast

lemma NshiftsE:
  assumes "z \<in> Nshifts"
  obtains t s where "s \<in> shifts" and "z = t +\<^sub>N s"
  using assms by auto

lemma image_swap_Nshifts [simp]: "prod.swap ` Nshifts = Nshifts"
proof -
  have "prod.swap ` Nshifts = case_prod (+\<^sub>N) ` (\<lambda>(x, y). (x, prod.swap y)) ` (UNIV \<times> shifts)"
    by (simp add: image_image prod.case_distrib swap_nat_plus_point_pair)
  also have "(\<lambda>(x, y). (x, prod.swap y)) ` (UNIV \<times> shifts) = UNIV \<times> prod.swap ` shifts"
    by (auto simp del: image_swap_shifts swap_simp intro!: image_eqI)
  finally show ?thesis by simp
qed

lemma Nshifts_is_nat_pm_pair: "z \<in> Nshifts \<Longrightarrow> is_nat_pm_pair z"
  by (elim NshiftsE) (simp add: nat_plus_point_pair_is_nat_pm_pair shifts_is_nat_pm_pair)

definition set_of_vpc :: "('x point \<times> 'x point) list \<Rightarrow> 'x point set"
  where "set_of_vpc zs = fst ` set zs \<union> snd ` set zs"

definition is_vpc :: "('x point \<times> 'x point) list \<Rightarrow> bool"
  where "is_vpc zs \<longleftrightarrow> zs \<noteq> [] \<and> (\<forall>i<length zs - 1. snd (zs ! i) = fst (zs ! Suc i)) \<and>
                      set zs \<subseteq> Nshifts"

lemma finite_set_of_vpc: "finite (set_of_vpc zs)"
  by (simp add: set_of_vpc_def)

lemma set_of_vpc_Nil [simp]: "set_of_vpc [] = {}"
  by (simp add: set_of_vpc_def)

lemma set_of_vpc_empty_iff: "set_of_vpc zs = {} \<longleftrightarrow> zs = []"
  by (simp add: set_of_vpc_def)

lemma set_of_vpc_Cons: "set_of_vpc (z # zs) = insert (fst z) (insert (snd z) (set_of_vpc zs))"
  by (simp add: set_of_vpc_def insert_commute)

lemma is_vpcI:
  "zs \<noteq> [] \<Longrightarrow> (\<And>i. Suc i < length zs \<Longrightarrow> snd (zs ! i) = fst (zs ! Suc i)) \<Longrightarrow> set zs \<subseteq> Nshifts \<Longrightarrow>
    is_vpc zs"
  by (simp add: is_vpc_def)

lemma is_vpcD:
  assumes "is_vpc zs"
  shows "zs \<noteq> []" and "Suc i < length zs \<Longrightarrow> snd (zs ! i) = fst (zs ! Suc i)" and "set zs \<subseteq> Nshifts"
  using assms by (simp_all add: is_vpc_def)

lemma is_vpcE:
  assumes "is_vpc zs" and "z \<in> set zs"
  obtains t s where "s \<in> shifts" and "z = t +\<^sub>N s"
  using assms by (auto dest!: is_vpcD(3))

lemma vpc_is_nat_pm_pair:
  assumes "is_vpc zs" and "z \<in> set zs"
  shows "is_nat_pm_pair z"
proof -
  from assms(1) have "set zs \<subseteq> Nshifts" by (rule is_vpcD)
  with assms(2) have "z \<in> Nshifts" ..
  thus ?thesis by (rule Nshifts_is_nat_pm_pair)
qed

lemma vpc_is_nat_pm:
  assumes "is_vpc zs" and "p \<in> set_of_vpc zs"
  shows "is_nat_pm p"
  using assms(2) unfolding set_of_vpc_def
proof
  assume "p \<in> fst ` set zs"
  then obtain z where "z \<in> set zs" and p: "p = fst z" ..
  from assms(1) this(1) have "is_nat_pm_pair z" by (rule vpc_is_nat_pm_pair)
  thus ?thesis unfolding p by (rule is_nat_pm_pairD)
next
  assume "p \<in> snd ` set zs"
  then obtain z where "z \<in> set zs" and p: "p = snd z" ..
  from assms(1) this(1) have "is_nat_pm_pair z" by (rule vpc_is_nat_pm_pair)
  thus ?thesis unfolding p by (rule is_nat_pm_pairD)
qed

lemma is_vpc_takeI: "is_vpc zs \<Longrightarrow> 0 < n \<Longrightarrow> is_vpc (take n zs)"
  using set_take_subset[of n zs] by (auto intro!: is_vpcI dest: is_vpcD)

lemma is_vpc_dropI:
  assumes "is_vpc zs" and "n < length zs"
  shows "is_vpc (drop n zs)"
proof (rule is_vpcI)
  from assms(2) show "drop n zs \<noteq> []" by simp
next
  fix i
  assume "Suc i < length (drop n zs)"
  with assms(2) have *: "Suc (n + i) < length zs" by simp
  from assms(2) have "snd (drop n zs ! i) = snd (zs ! (n + i))" by simp
  also from assms(1) * have "\<dots> = fst (zs ! Suc (n + i))" by (rule is_vpcD)
  also from assms(2) have "\<dots> = fst (drop n zs ! Suc i)" by simp
  finally show "snd (drop n zs ! i) = fst (drop n zs ! Suc i)" .
next
  from assms(1) have "set zs \<subseteq> Nshifts" by (rule is_vpcD)
  with set_drop_subset show "set (drop n zs) \<subseteq> Nshifts" by (rule subset_trans)
qed

lemma is_vpc_singleton [simp]: "is_vpc [z] \<longleftrightarrow> z \<in> Nshifts"
  by (simp add: is_vpc_def)

lemma is_vpc_appendI:
  assumes "is_vpc zs1" and "is_vpc zs2" and "snd (last zs1) = fst (hd zs2)"
  shows "is_vpc (zs1 @ zs2)"
proof (rule is_vpcI)
  from assms(2) have "zs2 \<noteq> []" by (rule is_vpcD)
  from assms(1) have "zs1 \<noteq> []" by (rule is_vpcD)
  thus "zs1 @ zs2 \<noteq> []" by simp

  fix i
  assume 1: "Suc i < length (zs1 @ zs2)"
  show "snd ((zs1 @ zs2) ! i) = fst ((zs1 @ zs2) ! Suc i)"
  proof (rule linorder_cases)
    assume 2: "Suc i < length zs1"
    with assms(1) have "snd (zs1 ! i) = fst (zs1 ! Suc i)" by (rule is_vpcD)
    with 2 show ?thesis by (simp add: nth_append)
  next
    assume 2: "Suc i = length zs1"
    hence 3: "i = length zs1 - 1" and "i < length zs1" by simp_all
    have "snd ((zs1 @ zs2) ! i) = snd (zs1 ! i)" by (simp add: nth_append \<open>i < length zs1\<close>)
    also from \<open>zs1 \<noteq> []\<close> have "\<dots> = snd (last zs1)" by (simp add: last_conv_nth 3)
    also have "\<dots> = fst (hd zs2)" by fact
    also from \<open>zs2 \<noteq> []\<close> have "\<dots> = fst (zs2 ! 0)" by (simp add: hd_conv_nth)
    also have "\<dots> = fst ((zs1 @ zs2) ! (Suc i))" by (simp add: nth_append 2)
    finally show ?thesis .
  next
    assume 2: "length zs1 < Suc i"
    with 1 have "Suc (i - length zs1) < length zs2" by simp
    with assms(2) have "snd (zs2 ! (i - length zs1)) = fst (zs2 ! Suc (i - length zs1))" by (rule is_vpcD)
    with 2 show ?thesis by (simp add: nth_append Suc_diff_le)
  qed
next
  from assms(1) have "set zs1 \<subseteq> Nshifts" by (rule is_vpcD)
  moreover from assms(2) have "set zs2 \<subseteq> Nshifts" by (rule is_vpcD)
  ultimately show "set (zs1 @ zs2) \<subseteq> Nshifts" by simp
qed

lemma is_vpc_ConsI:
  assumes "is_vpc zs" and "z \<in> Nshifts" and "snd z = fst (hd zs)"
  shows "is_vpc (z # zs)"
proof -
  have "is_vpc ([z] @ zs)" by (rule is_vpc_appendI) (simp_all add: assms)
  thus ?thesis by simp
qed

lemma is_vpc_ConsD:
  assumes "is_vpc (z # zs)"
  shows "z \<in> Nshifts" and "zs \<noteq> [] \<Longrightarrow> is_vpc zs" and "zs \<noteq> [] \<Longrightarrow> snd z = fst (hd zs)"
proof -
  have "z \<in> set (z # zs)" by simp
  also from assms have "\<dots> \<subseteq> Nshifts" by (rule is_vpcD)
  finally show "z \<in> Nshifts" .
next
  assume "zs \<noteq> []"
  hence "Suc 0 < length (z # zs)" by simp
  with assms have "is_vpc (drop (Suc 0) (z # zs))" and "snd ((z # zs) ! 0) = fst ((z # zs) ! Suc 0)"
    by (rule is_vpc_dropI, rule is_vpcD)
  thus "is_vpc zs" and "snd z = fst (hd zs)" using \<open>zs \<noteq> []\<close> by (simp_all add: hd_conv_nth)
qed

lemma is_vpc_revI:
  assumes "is_vpc zs"
  shows "is_vpc (map prod.swap (rev zs))" (is "is_vpc ?zs")
proof (rule is_vpcI)
  from assms have "zs \<noteq> []" by (rule is_vpcD)
  thus "?zs \<noteq> []" by simp
next
  fix i
  assume "Suc i < length ?zs"
  hence *: "Suc i < length zs" by simp
  moreover define j where "j = length zs - Suc (Suc i)"
  ultimately have Sj: "Suc j = length zs - Suc i" and **: "Suc j < length zs" by simp_all
  from * have "fst (?zs ! Suc i) = snd (zs ! j)" by (simp add: rev_nth j_def)
  also from assms ** have "\<dots> = fst (zs ! Suc j)" by (rule is_vpcD)
  also from * have "\<dots> = snd (?zs ! i)" by (simp add: rev_nth Sj)
  finally show "snd (?zs ! i) = fst (?zs ! Suc i)" by (rule sym)
next
  have "set ?zs = prod.swap ` set zs" by simp
  also from assms have "set zs \<subseteq> Nshifts" by (rule is_vpcD)
  finally have "set ?zs \<subseteq> prod.swap ` Nshifts" by blast
  thus "set ?zs \<subseteq> Nshifts" by simp
qed

lemma cut_vpc_fst:
  assumes "is_vpc zs" and "i < j" and "j < length zs" and "fst (zs ! i) = fst (zs ! j)"
  obtains zs' where "is_vpc zs'" and "fst (hd zs') = fst (hd zs)" and "snd (last zs') = snd (last zs)"
    and "set zs' \<subseteq> set zs" and "length zs = length zs' + (j - i)"
proof -
  from assms(1) have "zs \<noteq> []" by (rule is_vpcD)
  define zs2 where "zs2 = drop j zs"
  from assms(1, 3) have "is_vpc zs2" unfolding zs2_def by (rule is_vpc_dropI)
  hence "zs2 \<noteq> []" by (rule is_vpcD)
  from assms(3) have eq1: "hd zs2 = zs ! j" by (simp add: zs2_def hd_drop_conv_nth)
  from assms(3) have eq2: "last zs2 = last zs" by (simp add: zs2_def)
  show ?thesis
  proof (cases "i = 0")
    case True
    from \<open>is_vpc zs2\<close> show ?thesis
    proof
      from \<open>zs \<noteq> []\<close> assms(4) show "fst (hd zs2) = fst (hd zs)" by (simp add: eq1 hd_conv_nth True)
    next
      show "set zs2 \<subseteq> set zs" by (simp only: zs2_def set_drop_subset)
    next
      from assms(3) show "length zs = length zs2 + (j - i)" by (simp add: zs2_def True)
    qed (simp only: eq2)
  next
    case False
    hence "0 < i" by simp
    moreover define k where "k = i - 1"
    ultimately have i: "i = Suc k" by simp
    from assms(2, 3) have "i < length zs" by (rule less_trans)
    hence "k < length zs" by (simp add: k_def)
    define zs1 where "zs1 = take i zs"
    from assms(1) \<open>0 < i\<close> have "is_vpc zs1" unfolding zs1_def by (rule is_vpc_takeI)
    hence "zs1 \<noteq> []" by (rule is_vpcD)
    from \<open>0 < i\<close> have eq3: "hd zs1 = hd zs" by (simp add: zs1_def)
    from \<open>k < length zs\<close> have "snd (last zs1) = snd (zs ! k)"
      by (simp add: zs1_def last_take_conv_nth i)
    also from assms(1) \<open>i < length zs\<close> have "\<dots> = fst (zs ! i)" unfolding i by (rule is_vpcD)
    also have "\<dots> = fst (hd zs2)" by (simp only: assms(4) eq1)
    finally have eq4: "snd (last zs1) = fst (hd zs2)" .
    show ?thesis
    proof
      from \<open>is_vpc zs1\<close> \<open>is_vpc zs2\<close> eq4 show "is_vpc (zs1 @ zs2)" by (rule is_vpc_appendI)
    next
      from \<open>zs1 \<noteq> []\<close> show "fst (hd (zs1 @ zs2)) = fst (hd zs)" by (simp add: eq3)
    next
      from \<open>zs2 \<noteq> []\<close> show "snd (last (zs1 @ zs2)) = snd (last zs)" by (simp add: eq2)
    next
      show "set (zs1 @ zs2) \<subseteq> set zs" by (simp add: zs1_def zs2_def set_drop_subset set_take_subset)
    next
      from \<open>i < length zs\<close> assms(2, 3) show "length zs = length (zs1 @ zs2) + (j - i)"
        by (simp add: zs1_def zs2_def)
    qed
  qed
qed

lemma cut_vpc_snd:
  assumes "is_vpc zs" and "i < j" and "j < length zs" and "snd (zs ! i) = snd (zs ! j)"
  obtains zs' where "is_vpc zs'" and "fst (hd zs') = fst (hd zs)" and "snd (last zs') = snd (last zs)"
    and "set zs' \<subseteq> set zs" and "length zs = length zs' + (j - i)"
proof -
  from assms(2, 3) have "i < length zs" by (rule less_trans)
  from assms(1) have "zs \<noteq> []" by (rule is_vpcD)
  define zs1 where "zs1 = take (Suc i) zs"
  from assms(1) have "is_vpc zs1" unfolding zs1_def by (rule is_vpc_takeI) simp
  hence "zs1 \<noteq> []" by (rule is_vpcD)
  have eq1: "hd zs1 = hd zs" by (simp add: zs1_def)
  from \<open>i < length zs\<close> have eq2: "last zs1 = zs ! i" by (simp add: zs1_def last_take_conv_nth)
  show ?thesis
  proof (cases "Suc j = length zs")
    case True
    from \<open>is_vpc zs1\<close> show ?thesis
    proof
      from \<open>zs \<noteq> []\<close> assms(3, 4) show "snd (last zs1) = snd (last zs)"
        by (simp add: eq2 last_conv_nth flip: True)
    next
      show "set zs1 \<subseteq> set zs" by (simp only: zs1_def set_take_subset)
    next
      from assms(3) show "length zs = length zs1 + (j - i)" by (simp add: zs1_def flip: True)
    qed (simp only: eq1)
  next
    case False
    with assms(3) have *: "Suc j < length zs" by simp
    define zs2 where "zs2 = drop (Suc j) zs"
    from assms(1) * have "is_vpc zs2" unfolding zs2_def by (rule is_vpc_dropI)
    hence "zs2 \<noteq> []" by (rule is_vpcD)
    from * have eq4: "last zs2 = last zs" by (simp add: zs2_def)
    have "snd (last zs1) = snd (zs ! j)" by (simp only: assms(4) eq2)
    also from assms(1) * have "\<dots> = fst (zs ! Suc j)" by (rule is_vpcD)
    also from * have "\<dots> = fst (hd zs2)" by (simp add: zs2_def hd_drop_conv_nth)
    finally have eq3: "snd (last zs1) = fst (hd zs2)" .
    show ?thesis
    proof
      from \<open>is_vpc zs1\<close> \<open>is_vpc zs2\<close> eq3 show "is_vpc (zs1 @ zs2)" by (rule is_vpc_appendI)
    next
      from \<open>zs1 \<noteq> []\<close> show "fst (hd (zs1 @ zs2)) = fst (hd zs)" by (simp add: eq1)
    next
      from \<open>zs2 \<noteq> []\<close> show "snd (last (zs1 @ zs2)) = snd (last zs)" by (simp add: eq4)
    next
      show "set (zs1 @ zs2) \<subseteq> set zs" by (simp add: zs1_def zs2_def set_drop_subset set_take_subset)
    next
      from \<open>i < length zs\<close> assms(2, 3) show "length zs = length (zs1 @ zs2) + (j - i)"
        by (simp add: zs1_def zs2_def)
    qed
  qed
qed

lemma vpc_induct [consumes 1, case_names single Cons]:
  assumes "is_vpc zs" and "\<And>z. z \<in> Nshifts \<Longrightarrow> P [z]"
    and "\<And>z zs. is_vpc zs \<Longrightarrow> z \<in> Nshifts \<Longrightarrow> snd z = fst (hd zs) \<Longrightarrow> P zs \<Longrightarrow> P (z # zs)"
  shows "P zs"
  using assms(1)
proof (induct zs)
  case Nil
  thus ?case by (simp add: is_vpc_def)
next
  case (Cons z zs)
  from Cons(2) have 1: "z \<in> Nshifts" by (rule is_vpc_ConsD)
  show ?case
  proof (cases "zs = []")
    case True
    moreover from 1 have "P [z]" by (rule assms(2))
    ultimately show ?thesis by simp
  next
    case False
    with Cons(2) have 2: "is_vpc zs" and 3: "snd z = fst (hd zs)" by (rule is_vpc_ConsD)+
    from this(1) have "P zs" by (rule Cons(1))
    with 2 1 3 show ?thesis by (rule assms(3))
  qed
qed

context
  assumes f1_pbinomial: "is_proper_binomial f1"
  assumes f2_pbinomial: "is_proper_binomial f2"
begin

lemma shifts_fst_not_eq_snd: "s \<in> shifts \<Longrightarrow> fst s \<noteq> snd s"
proof (elim shifts_cases_poly)
  from f1_pbinomial have "fst (poly_point f1) \<noteq> snd (poly_point f1)"
    by (simp add: fst_eq_snd_poly_point_iff is_proper_binomial_def)
  moreover assume "s = poly_point f1 \<or> s = prod.swap (poly_point f1)"
  ultimately show ?thesis by auto
next
  from f2_pbinomial have "fst (poly_point f2) \<noteq> snd (poly_point f2)"
    by (simp add: fst_eq_snd_poly_point_iff is_proper_binomial_def)
  moreover assume "s = poly_point f2 \<or> s = prod.swap (poly_point f2)"
  ultimately show ?thesis by auto
qed

lemma Nshifts_fst_not_eq_snd: "z \<in> Nshifts \<Longrightarrow> fst z \<noteq> snd z"
  by (elim NshiftsE) (simp add: shifts_fst_not_eq_snd)

lemma vpc_fst_not_eq_snd:
  assumes "is_vpc zs" and "z \<in> set zs"
  shows "fst z \<noteq> snd z" and "to_nat_pm (fst z) \<noteq> to_nat_pm (snd z)"
proof -
  from assms(1) have "set zs \<subseteq> Nshifts" by (rule is_vpcD)
  with assms(2) have "z \<in> Nshifts" ..
  thus "fst z \<noteq> snd z" by (rule Nshifts_fst_not_eq_snd)

  from assms have "is_nat_pm_pair z" by (rule vpc_is_nat_pm_pair)
  hence "is_nat_pm (fst z)" and "is_nat_pm (snd z)" by (rule is_nat_pm_pairD)+
  hence "of_nat_pm (to_nat_pm (fst z)) = fst z" and "of_nat_pm (to_nat_pm (snd z)) = snd z"
    by (simp_all add: of_nat_pm_comp_to_nat_pm)
  with \<open>fst z \<noteq> snd z\<close> have "of_nat_pm (to_nat_pm (fst z)) \<noteq> (of_nat_pm (to_nat_pm (snd z))::_ \<Rightarrow>\<^sub>0 rat)"
    by simp
  thus "to_nat_pm (fst z) \<noteq> to_nat_pm (snd z)" by simp
qed

text \<open>If VPCs were defined w.r.t. arbitrary sets of polynomials, the following lemma could most
  probably be proved for arbitrary sets of proper binomials.\<close>

lemma idealE_vpc:
  assumes "f \<in> ideal {f1, f2}" and "is_proper_binomial f" and "monomial 1 (lp f) \<notin> ideal {f1, f2}"
  obtains zs where "is_vpc zs" and "fst (hd zs) = of_nat_pm (lp f)" and "snd (last zs) = of_nat_pm (tp f)"
proof -
  let ?l = "of_nat_pm (lp f)"
  define F where "F = {f1, f2}"
  have "finite F" by (simp add: F_def)
  moreover from assms(1) have "f \<in> ideal F" by (simp only: F_def)
  ultimately obtain q where f: "f = (\<Sum>f0\<in>F. q f0 * f0)" by (rule ideal.span_finiteE)
  from assms(2) have keys_f: "keys f = {lp f, tp f}" by (rule punit.keys_proper_binomial)
  define Y where "Y = (\<lambda>f0. {t \<in> keys (q f0). \<exists>zs. is_vpc zs \<and> fst (hd zs) = ?l \<and>
                            (t +\<^sub>N poly_point f0 \<in> set zs \<or> t +\<^sub>N prod.swap (poly_point f0) \<in> set zs)})"
  define q' where "q' = (\<lambda>f0. except (q f0) (- Y f0))"
  define q'' where "q'' = (\<lambda>f0. except (q f0) (Y f0))"
  have "Y f0 \<subseteq> keys (q f0)" for f0 by (simp add: Y_def)
  hence keys_q': "keys (q' f0) = Y f0" for f0 by (simp add: q'_def keys_except Int_absorb1)
  let ?f = "(\<Sum>f0\<in>F. q' f0 * f0)"
  have vpcE: thesis0
    if "t \<in> keys ?f" and "\<And>zs. is_vpc zs \<Longrightarrow> fst (hd zs) = ?l \<Longrightarrow> snd (last zs) = of_nat_pm t \<Longrightarrow> thesis0"
    for thesis0 t
  proof -
    have "keys ?f \<subseteq> (\<Union>f0\<in>F. keys (q' f0 * f0))" by (rule keys_sum_subset)
    with that(1) have "t \<in> (\<Union>f0\<in>F. keys (q' f0 * f0))" ..
    thus ?thesis
    proof
      fix f0
      assume "f0 \<in> F"
      hence "f0 = f1 \<or> f0 = f2" by (simp add: F_def)
      with f1_pbinomial f2_pbinomial have "is_proper_binomial f0" by blast
      hence keys_f0: "keys f0 = {lp f0, tp f0}" by (rule punit.keys_proper_binomial)
      assume "t \<in> keys (q' f0 * f0)"
      then obtain s u where "s \<in> keys (q' f0)" and "u \<in> keys f0" and t: "t = s + u"
        by (rule in_keys_timesE)
      from this(2) have u_cases: "u = lp f0 \<or> u = tp f0" by (simp add: keys_f0)
      from \<open>s \<in> keys (q' f0)\<close> obtain zs where "is_vpc zs" and eq1: "fst (hd zs) = ?l"
        and "s +\<^sub>N poly_point f0 \<in> set zs \<or> s +\<^sub>N prod.swap (poly_point f0) \<in> set zs"
        unfolding keys_q' Y_def by blast
      from this(3) show ?thesis
      proof
        assume "s +\<^sub>N poly_point f0 \<in> set zs"
        then obtain i where "i < length zs" and eq2: "zs ! i = s +\<^sub>N poly_point f0"
          by (meson in_set_conv_nth)
        let ?zs = "take (Suc i) zs"
        from \<open>is_vpc zs\<close> have "is_vpc ?zs" by (rule is_vpc_takeI) simp
        have eq3: "fst (hd ?zs) = ?l" by (simp add: eq1)
        from \<open>i < length zs\<close> have eq4: "last ?zs = s +\<^sub>N poly_point f0" and "?zs \<noteq> []"
          by (auto simp: last_take_conv_nth eq2)
        from u_cases show ?thesis
        proof
          assume u: "u = lp f0"
          let ?ys = "?zs @ [s +\<^sub>N prod.swap (poly_point f0)]"
          from \<open>is_vpc ?zs\<close> have "is_vpc ?ys"
          proof (rule is_vpc_appendI)
            from \<open>f0 \<in> F\<close> show "is_vpc [s +\<^sub>N prod.swap (poly_point f0)]"
              by (auto simp: F_def intro: NshiftsI shiftsI)
          qed (simp add: eq4 nat_plus_point_pair_def)
          moreover from \<open>?zs \<noteq> []\<close> have "fst (hd ?ys) = ?l" by (simp add: eq1)
          moreover from \<open>i < length zs\<close> have "snd (last ?ys) = of_nat_pm t"
            by (simp add: nat_plus_point_pair_def t u fst_poly_point of_nat_pm_plus)
          ultimately show ?thesis by (rule that(2))
        next
          assume "u = tp f0"
          hence "snd (last ?zs) = of_nat_pm t"
            by (simp add: eq4 nat_plus_point_pair_def snd_poly_point t of_nat_pm_plus)
          with \<open>is_vpc ?zs\<close> eq3 show ?thesis by (rule that(2))
        qed
      next
        assume "s +\<^sub>N prod.swap (poly_point f0) \<in> set zs"
        then obtain i where "i < length zs" and eq2: "zs ! i = s +\<^sub>N prod.swap (poly_point f0)"
          by (meson in_set_conv_nth)
        let ?zs = "take (Suc i) zs"
        from \<open>is_vpc zs\<close> have "is_vpc ?zs" by (rule is_vpc_takeI) simp
        have eq3: "fst (hd ?zs) = ?l" by (simp add: eq1)
        from \<open>i < length zs\<close> have eq4: "last ?zs = s +\<^sub>N prod.swap (poly_point f0)" and "?zs \<noteq> []"
          by (auto simp: last_take_conv_nth eq2)
        from u_cases show ?thesis
        proof
          assume u: "u = tp f0"
          let ?ys = "?zs @ [s +\<^sub>N poly_point f0]"
          from \<open>is_vpc ?zs\<close> have "is_vpc ?ys"
          proof (rule is_vpc_appendI)
            from \<open>f0 \<in> F\<close> show "is_vpc [s +\<^sub>N poly_point f0]"
              by (auto simp: F_def intro: NshiftsI shiftsI)
          qed (simp add: eq4 nat_plus_point_pair_def)
          moreover from \<open>?zs \<noteq> []\<close> have "fst (hd ?ys) = ?l" by (simp add: eq1)
          moreover from \<open>i < length zs\<close> have "snd (last ?ys) = of_nat_pm t"
            by (simp add: nat_plus_point_pair_def t u snd_poly_point of_nat_pm_plus)
          ultimately show ?thesis by (rule that(2))
        next
          assume "u = lp f0"
          hence "snd (last ?zs) = of_nat_pm t"
            by (simp add: eq4 nat_plus_point_pair_def fst_poly_point t of_nat_pm_plus)
          with \<open>is_vpc ?zs\<close> eq3 show ?thesis by (rule that(2))
        qed
      qed
    qed
  qed
  have "f = (\<Sum>f0\<in>F. (q'' f0 + q' f0) * f0)" by (simp only: q''_def q'_def f flip: except_decomp)
  also have "\<dots> = (\<Sum>f0\<in>F. q'' f0 * f0) + ?f" (is "_ = ?g + _") by (simp add: algebra_simps sum.distrib)
  finally have f': "f = ?g + ?f" .
  have 1: "t \<notin> keys ?g" if "is_vpc zs" and "fst (hd zs) = ?l" and "snd (last zs) = of_nat_pm t" for t zs
  proof
    from that(1) have "zs \<noteq> []" by (rule is_vpcD)
    assume "t \<in> keys ?g"
    also have "\<dots> \<subseteq> (\<Union>f0\<in>F. keys (q'' f0 * f0))" by (rule keys_sum_subset)
    finally have "t \<in> (\<Union>f0\<in>F. keys (q'' f0 * f0))" .
    thus False
    proof
      fix f0
      assume "f0 \<in> F"
      hence "f0 = f1 \<or> f0 = f2" by (simp add: F_def)
      with f1_pbinomial f2_pbinomial have "is_proper_binomial f0" by blast
      hence keys_f0: "keys f0 = {lp f0, tp f0}" by (rule punit.keys_proper_binomial)
      assume "t \<in> keys (q'' f0 * f0)"
      then obtain s u where "s \<in> keys (q'' f0)" and "u \<in> keys f0" and t: "t = s + u"
        by (rule in_keys_timesE)
      have "keys (q'' f0) \<subseteq> keys (q f0)" by (simp add: q''_def keys_except)
      with \<open>s \<in> keys (q'' f0)\<close> have "s \<in> keys (q f0)" ..
      from \<open>u \<in> keys f0\<close> have u_cases: "u = lp f0 \<or> u = tp f0" by (simp add: keys_f0)
      thus ?thesis
      proof
        assume u: "u = lp f0"
        let ?zs = "zs @ [s +\<^sub>N poly_point f0]"
        from \<open>is_vpc zs\<close> have "is_vpc ?zs"
        proof (rule is_vpc_appendI)
          from \<open>f0 \<in> F\<close> show "is_vpc [s +\<^sub>N poly_point f0]"
            by (auto simp: F_def intro: NshiftsI shiftsI)
        qed (simp add: that(3) nat_plus_point_pair_def fst_poly_point t u of_nat_pm_plus)
        moreover from \<open>zs \<noteq> []\<close> have "fst (hd ?zs) = ?l" by (simp add: that(2))
        ultimately have "s \<in> Y f0" using \<open>s \<in> keys (q f0)\<close> by (auto simp: Y_def)
        hence "s \<notin> keys (q'' f0)" by (simp add: q''_def keys_except)
        thus ?thesis using \<open>s \<in> keys (q'' f0)\<close> ..
      next
        assume u: "u = tp f0"
        let ?zs = "zs @ [s +\<^sub>N prod.swap (poly_point f0)]"
        from \<open>is_vpc zs\<close> have "is_vpc ?zs"
        proof (rule is_vpc_appendI)
          from \<open>f0 \<in> F\<close> show "is_vpc [s +\<^sub>N prod.swap (poly_point f0)]"
            by (auto simp: F_def intro: NshiftsI shiftsI)
        qed (simp add: that(3) nat_plus_point_pair_def snd_poly_point t u of_nat_pm_plus)
        moreover from \<open>zs \<noteq> []\<close> have "fst (hd ?zs) = ?l" by (simp add: that(2))
        ultimately have "s \<in> Y f0" using \<open>s \<in> keys (q f0)\<close> by (auto simp: Y_def)
        hence "s \<notin> keys (q'' f0)" by (simp add: q''_def keys_except)
        thus ?thesis using \<open>s \<in> keys (q'' f0)\<close> ..
      qed
    qed
  qed
  have disjnt: "keys ?g \<inter> keys ?f = {}"
  proof (intro subset_antisym subsetI)
    fix t
    assume "t \<in> keys ?g \<inter> keys ?f"
    hence "t \<in> keys ?g" and "t \<in> keys ?f" by simp_all
    from this(2) obtain zs where "is_vpc zs" and "fst (hd zs) = ?l"
      and "snd (last zs) = of_nat_pm t" by (rule vpcE)
    hence "t \<notin> keys ?g" by (rule 1)
    thus "t \<in> {}" using \<open>t \<in> keys ?g\<close> ..
  qed simp
  hence "keys ?g \<union> keys ?f = keys (?g + ?f)" by (rule keys_add)
  also have "\<dots> = {lp f, tp f}" by (simp only: keys_f flip: f')
  finally have *: "keys ?g \<union> keys ?f = {lp f, tp f}" .
  moreover have "lp f \<notin> keys ?g"
  proof -
    have "lp f \<in> keys f" by (simp add: keys_f)
    also have "\<dots> \<subseteq> (\<Union>f0\<in>F. keys (q f0 * f0))" unfolding f by (rule keys_sum_subset)
    finally obtain f0 where "f0 \<in> F" and "lp f \<in> keys (q f0 * f0)" ..
    from this(2) obtain s u where "s \<in> keys (q f0)" and "u \<in> keys f0" and lp: "lp f = s + u"
      by (rule in_keys_timesE)
    from \<open>f0 \<in> F\<close> have f0_cases: "f0 = f1 \<or> f0 = f2" by (simp add: F_def)
    with f1_pbinomial f2_pbinomial have "is_proper_binomial f0" by blast
    hence "keys f0 = {lp f0, tp f0}" by (rule punit.keys_proper_binomial)
    with \<open>u \<in> keys f0\<close> have "u = lp f0 \<or> u = tp f0" by simp
    thus ?thesis
    proof
      assume u: "u = lp f0"
      let ?zs = "[s +\<^sub>N poly_point f0, s +\<^sub>N prod.swap (poly_point f0)]"
      have "is_vpc ?zs"
      proof (rule is_vpc_ConsI)
        from \<open>f0 \<in> F\<close> show "is_vpc [s +\<^sub>N prod.swap (poly_point f0)]"
          by (auto simp: F_def intro: NshiftsI shiftsI)
      next
        from \<open>f0 \<in> F\<close> show "s +\<^sub>N poly_point f0 \<in> Nshifts" unfolding F_def by (intro NshiftsI shiftsI)
      qed (simp add: nat_plus_point_pair_def)
      moreover have "fst (hd ?zs) = of_nat_pm (lp f)" and "snd (last ?zs) = of_nat_pm (lp f)"
        by (simp_all add: nat_plus_point_pair_def poly_point_def lp u of_nat_pm_plus)
      ultimately show ?thesis by (rule 1)
    next
      assume u: "u = tp f0"
      let ?zs = "[s +\<^sub>N prod.swap (poly_point f0), s +\<^sub>N poly_point f0]"
      have "is_vpc ?zs"
      proof (rule is_vpc_ConsI)
        from \<open>f0 \<in> F\<close> show "is_vpc [s +\<^sub>N poly_point f0]"
          by (auto simp: F_def intro: NshiftsI shiftsI)
      next
        from \<open>f0 \<in> F\<close> show "s +\<^sub>N prod.swap (poly_point f0) \<in> Nshifts"
          unfolding F_def by (intro NshiftsI shiftsI)
      qed (simp add: nat_plus_point_pair_def)
      moreover have "fst (hd ?zs) = of_nat_pm (lp f)" and "snd (last ?zs) = of_nat_pm (lp f)"
        by (simp_all add: nat_plus_point_pair_def poly_point_def lp u of_nat_pm_plus)
      ultimately show ?thesis by (rule 1)
    qed
  qed
  ultimately have "lp f \<in> keys ?f" by blast
  have "tp f \<in> keys ?f"
  proof (rule ccontr)
    assume "tp f \<notin> keys ?f"
    with \<open>lp f \<in> keys ?f\<close> * have keys_f': "keys ?f = {lp f}" by blast
    moreover define c where "c = lookup ?f (lp f)"
    ultimately have "monomial c (lp f) = ?f"
      by (auto intro!: poly_mapping_eqI simp: lookup_single when_def)
    also have "\<dots> \<in> ideal F" by (rule ideal.sum_in_spanI)
    finally have "monomial (1 / c) 0 * monomial c (lp f) \<in> ideal F" by (rule ideal.span_scale)
    moreover have "c \<noteq> 0" by (simp add: c_def keys_f')
    ultimately have "monomial 1 (lp f) \<in> ideal {f1, f2}" by (simp add: times_monomial_monomial F_def)
    with assms(3) show False ..
  qed
  then obtain zs where "is_vpc zs" and "fst (hd zs) = ?l" and "snd (last zs) = of_nat_pm (tp f)"
    by (rule vpcE)
  thus ?thesis ..
qed

text \<open>Lemma \<open>idealE_vpc\<close> corresponds to Theorem 3.3.14 in @{cite "MWW2015"}. There, however, it is
  proved quite differently, relying on the fairly complicated Lemma 3.3.11. The proof of this lemma
  contains a substantial gap which, intuitively, seems correct and could thus be closed, but I have
  no idea how to do it rigorously. That is the reason for the different approach here.\<close>

definition deg_vpc :: "('x point \<times> 'x point) list \<Rightarrow> rat"
  where "deg_vpc zs = (if zs = [] then 0 else Max (deg_pm ` set_of_vpc zs))"

text \<open>Although @{const deg_vpc} will mostly be applied to arguments \<open>zs\<close> satisfying @{prop "is_vpc zs"}
  and which are therefore not empty, it still makes sense to treat the case @{prop "zs = []"}
  separately in the definition of @{const deg_vpc}.\<close>

lemma deg_vpc_max:
  assumes "p \<in> set_of_vpc zs"
  shows "deg_pm p \<le> deg_vpc zs"
proof -
  from finite_set_of_vpc have "finite (deg_pm ` set_of_vpc zs)" by (rule finite_imageI)
  moreover from assms have "deg_pm p \<in> deg_pm ` set_of_vpc zs" by (rule imageI)
  ultimately have "deg_pm p \<le> Max (deg_pm ` set_of_vpc zs)" by (rule Max_ge)
  with assms show ?thesis by (auto simp: deg_vpc_def)
qed

lemma deg_vpc_leI:
  assumes "\<And>p. p \<in> set_of_vpc zs \<Longrightarrow> deg_pm p \<le> rat d"
  shows "deg_vpc zs \<le> rat d"
proof (cases "zs = []")
  case True
  thus ?thesis by (simp add: deg_vpc_def)
next
  case False
  from finite_set_of_vpc have "finite (deg_pm ` set_of_vpc zs)" by (rule finite_imageI)
  moreover from False have "deg_pm ` set_of_vpc zs \<noteq> {}" by (simp add: set_of_vpc_empty_iff)
  ultimately have "Max (deg_pm ` set_of_vpc zs) \<le> rat d"
  proof (rule Max.boundedI)
    fix a
    assume "a \<in> deg_pm ` set_of_vpc zs"
    then obtain p where "p \<in> set_of_vpc zs" and a: "a = deg_pm p" ..
    from this(1) show "a \<le> rat d" unfolding a by (rule assms)
  qed
  with False show ?thesis by (simp add: deg_vpc_def)
qed

lemma deg_vpc_Cons: "zs \<noteq> [] \<Longrightarrow> deg_vpc (z # zs) = max (deg_vpc [z]) (deg_vpc zs)"
  by (simp add: deg_vpc_def set_of_vpc_Cons finite_set_of_vpc max.assoc set_of_vpc_empty_iff)

corollary deg_vpc_Cons_ge: "deg_vpc [z] \<le> deg_vpc (z # zs)"
  by (cases "zs = []") (simp_all add: deg_vpc_Cons)

lemma vpcE_ideal_singleton:
  assumes "z \<in> Nshifts"
  obtains q1 q2 where "of_nat_pm ` keys (q1 * f1 + q2 * f2) = {fst z, snd z}"
    and "rat (poly_deg (q1 * f1)) \<le> deg_vpc [z]" and "rat (poly_deg (q2 * f2)) \<le> deg_vpc [z]"
proof -
  from assms obtain t s where "s \<in> shifts" and z: "z = t +\<^sub>N s" by (rule NshiftsE)
  from this(1) show ?thesis
  proof (rule shifts_cases_poly)
    assume "s = poly_point f1 \<or> s = prod.swap (poly_point f1)"
    hence eq1: "{fst z, snd z} = of_nat_pm ` {t + lp f1, t + tp f1}"
      by (auto simp: z poly_point_def nat_plus_point_pair_def of_nat_pm_plus)
    hence eq1': "set_of_vpc [z] = of_nat_pm ` {t + lp f1, t + tp f1}" by (simp add: set_of_vpc_Cons)
    show ?thesis
    proof
      have "keys (monomial 1 t * f1 + 0 * f2) = keys (monomial 1 t * f1)" by simp
      also from f1_pbinomial have eq2: "keys (monomial 1 t * f1) = {t + lp f1, t + tp f1}"
        by (simp add: times_monomial_left punit.keys_monom_mult punit.keys_proper_binomial)
      finally show "of_nat_pm ` keys (monomial 1 t * f1 + 0 * f2) = {fst z, snd z}"
        by (simp only: eq1)

      have "poly_deg (monomial 1 t * f1) \<le> max (deg_pm (t + lp f1)) (deg_pm (t + tp f1))"
        by (rule poly_deg_leI) (auto simp: eq2)
      also have "rat \<dots> = max (deg_pm (of_nat_pm (t + lp f1))) (deg_pm (of_nat_pm (t + tp f1)))"
        by (simp add: deg_of_nat_pm)
      also have "\<dots> \<le> deg_vpc [z]" by (intro max.boundedI deg_vpc_max) (simp_all add: eq1')
      finally show "rat (poly_deg (monomial 1 t * f1)) \<le> deg_vpc [z]" by simp

      have "rat (poly_deg (0 * f2)) \<le> rat (poly_deg (monomial 1 t * f1))" by simp
      also have "\<dots> \<le> deg_vpc [z]" by fact
      finally show "rat (poly_deg (0 * f2)) \<le> deg_vpc [z]" .
    qed
  next
    assume "s = poly_point f2 \<or> s = prod.swap (poly_point f2)"
    hence eq1: "{fst z, snd z} = of_nat_pm ` {t + lp f2, t + tp f2}"
      by (auto simp: z poly_point_def nat_plus_point_pair_def of_nat_pm_plus)
    hence eq1': "set_of_vpc [z] = of_nat_pm ` {t + lp f2, t + tp f2}" by (simp add: set_of_vpc_Cons)
    show ?thesis
    proof
      have "keys (0 * f1 + monomial 1 t * f2) = keys (monomial 1 t * f2)" by simp
      also from f2_pbinomial have eq2: "keys (monomial 1 t * f2) = {t + lp f2, t + tp f2}"
        by (simp add: times_monomial_left punit.keys_monom_mult punit.keys_proper_binomial)
      finally show "of_nat_pm ` keys (0 * f1 + monomial 1 t * f2) = {fst z, snd z}"
        by (simp only: eq1)

      have "poly_deg (monomial 1 t * f2) \<le> max (deg_pm (t + lp f2)) (deg_pm (t + tp f2))"
        by (rule poly_deg_leI) (auto simp: eq2)
      also have "rat \<dots> = max (deg_pm (of_nat_pm (t + lp f2))) (deg_pm (of_nat_pm (t + tp f2)))"
        by (simp add: deg_of_nat_pm)
      also have "\<dots> \<le> deg_vpc [z]" by (intro max.boundedI deg_vpc_max) (simp_all add: eq1')
      finally show "rat (poly_deg (monomial 1 t * f2)) \<le> deg_vpc [z]" by simp

      have "rat (poly_deg (0 * f1)) \<le> rat (poly_deg (monomial 1 t * f2))" by simp
      also have "\<dots> \<le> deg_vpc [z]" by fact
      finally show "rat (poly_deg (0 * f1)) \<le> deg_vpc [z]" .
    qed
  qed
qed

lemma vpcE_ideal:
  assumes "is_vpc zs" and "fst (hd zs) \<noteq> snd (last zs)"
  obtains q1 q2 where "of_nat_pm ` keys (q1 * f1 + q2 * f2) = {fst (hd zs), snd (last zs)}"
    and "rat (poly_deg (q1 * f1)) \<le> deg_vpc zs" and "rat (poly_deg (q2 * f2)) \<le> deg_vpc zs"
  using assms
proof (induct zs arbitrary: thesis rule: vpc_induct)
  case (single z)
  from single(1) obtain q1 q2 where "of_nat_pm ` keys (q1 * f1 + q2 * f2) = {fst z, snd z}"
    and 1: "rat (poly_deg (q1 * f1)) \<le> deg_vpc [z]" and 2: "rat (poly_deg (q2 * f2)) \<le> deg_vpc [z]"
    by (rule vpcE_ideal_singleton)
  from this(1) have "of_nat_pm ` keys (q1 * f1 + q2 * f2) = {fst (hd [z]), snd (last [z])}"
    by simp
  thus ?case using 1 2 by (rule single)
next
  case (Cons z zs)
  from Cons.hyps(1) have "zs \<noteq> []" by (rule is_vpcD)
  with Cons.prems(2) have "fst z \<noteq> snd (last zs)" by simp
  from Cons.hyps(2) have "is_nat_pm_pair z" by (rule Nshifts_is_nat_pm_pair)
  hence "is_nat_pm (fst z)" by (rule is_nat_pm_pairD)
  hence eq_z: "of_nat_pm (to_nat_pm (fst z)) = fst z" by (simp add: of_nat_pm_comp_to_nat_pm)
  from Cons.hyps(1) last_in_set have "is_nat_pm_pair (last zs)"
    by (rule vpc_is_nat_pm_pair) fact
  hence "is_nat_pm (snd (last zs))" by (rule is_nat_pm_pairD)
  hence eq0: "of_nat_pm (to_nat_pm (snd (last zs))) = snd (last zs)"
    by (simp add: of_nat_pm_comp_to_nat_pm)
  hence "of_nat_pm (to_nat_pm (fst z)) \<noteq> (of_nat_pm (to_nat_pm (snd (last zs)))::_ \<Rightarrow>\<^sub>0 rat)"
    using \<open>fst z \<noteq> snd (last zs)\<close> by (simp add: eq_z)
  hence neq1: "to_nat_pm (fst z) \<noteq> to_nat_pm (snd (last zs))" by simp
  from Cons.hyps(2) have "is_vpc [z]" by simp
  hence neq2: "to_nat_pm (fst z) \<noteq> to_nat_pm (snd z)" by (rule vpc_fst_not_eq_snd) simp
  from Cons.hyps(2) obtain q1 q2 where eq1: "of_nat_pm ` keys (q1 * f1 + q2 * f2) = {fst z, snd z}"
    and 10: "rat (poly_deg (q1 * f1)) \<le> deg_vpc [z]" and 20: "rat (poly_deg (q2 * f2)) \<le> deg_vpc [z]"
    by (rule vpcE_ideal_singleton)
  let ?f = "q1 * f1 + q2 * f2"
  from 10 deg_vpc_Cons_ge have 1: "rat (poly_deg (q1 * f1)) \<le> deg_vpc (z # zs)" by (rule order.trans)
  from 20 deg_vpc_Cons_ge have 2: "rat (poly_deg (q2 * f2)) \<le> deg_vpc (z # zs)" by (rule order.trans)
  show ?case
  proof (cases "fst (hd zs) = snd (last zs)")
    case True
    with \<open>zs \<noteq> []\<close> have eq2: "snd (last (z # zs)) = snd z" by (simp add: Cons.hyps(3))
    have "of_nat_pm ` keys ?f = {fst (hd (z # zs)), snd (last (z # zs))}"
      by (simp only: eq1 eq2 list.sel(1))
    thus ?thesis using 1 2 by (rule Cons.prems)
  next
    case False
    then obtain q1' q2' where eq2: "of_nat_pm ` keys (q1' * f1 + q2' * f2) = {fst (hd zs), snd (last zs)}"
      and 30: "rat (poly_deg (q1' * f1)) \<le> deg_vpc zs" and 40: "rat (poly_deg (q2' * f2)) \<le> deg_vpc zs"
      using Cons.hyps(4) by blast
    from \<open>zs \<noteq> []\<close> 30 have 3: "rat (poly_deg (q1' * f1)) \<le> deg_vpc (z # zs)" by (simp add: deg_vpc_Cons)
    from \<open>zs \<noteq> []\<close> 40 have 4: "rat (poly_deg (q2' * f2)) \<le> deg_vpc (z # zs)" by (simp add: deg_vpc_Cons)
    let ?g = "q1' * f1 + q2' * f2"
    have eq3: "of_nat_pm ` keys (q1' * f1 + q2' * f2) = {snd z, snd (last zs)}"
      by (simp only: eq2 Cons.hyps(3))
    define c where "c = lookup ?f (to_nat_pm (snd z))"
    define d where "d = lookup ?g (to_nat_pm (snd z))"
    have "keys ?f = to_nat_pm ` (of_nat_pm::_ \<Rightarrow> ('x \<Rightarrow>\<^sub>0 rat)) ` keys ?f" by (simp add: image_image)
    also have "\<dots> = {to_nat_pm (fst z), to_nat_pm (snd z)}" by (simp add: eq1)
    finally have keys_f: "keys ?f = {to_nat_pm (fst z), to_nat_pm (snd z)}" .
    hence "c \<noteq> 0" by (simp add: c_def)
    have "keys ?g = to_nat_pm ` (of_nat_pm::_ \<Rightarrow> ('x \<Rightarrow>\<^sub>0 rat)) ` keys ?g" by (simp add: image_image)
    also have "\<dots> = {to_nat_pm (snd z), to_nat_pm (snd (last zs))}" by (simp add: eq3)
    finally have keys_g: "keys ?g = {to_nat_pm (snd z), to_nat_pm (snd (last zs))}" .
    hence "d \<noteq> 0" by (simp add: d_def)
    with \<open>c \<noteq> 0\<close> have "- (c / d) \<noteq> 0" by simp
    hence keys_g': "keys ((- (c / d)) \<cdot> ?g) = {to_nat_pm (snd z), to_nat_pm (snd (last zs))}"
      by (simp add: keys_map_scale keys_g)
    define q1'' where "q1'' = - (c / d) \<cdot> q1'"
    define q2'' where "q2'' = - (c / d) \<cdot> q2'"
    show ?thesis
    proof (rule Cons.prems)
      have "keys ((q1 + q1'') * f1 + (q2 + q2'') * f2) = keys (?f + (- (c / d)) \<cdot> ?g)"
        by (simp add: q1''_def q2''_def map_scale_eq_times algebra_simps)
      also have "\<dots> = {to_nat_pm (fst z), to_nat_pm (snd (last zs))}" (is "?A = ?B")
      proof (intro subset_antisym insert_subsetI empty_subsetI, rule subsetI)
        fix t
        assume "t \<in> ?A"
        also have "\<dots> \<subseteq> keys ?f \<union> keys ((- (c / d)) \<cdot> ?g)" by (rule keys_add_subset)
        finally have "t \<in> insert (to_nat_pm (snd z)) ?B" by (auto simp: keys_f keys_g')
        moreover have "t \<noteq> to_nat_pm (snd z)"
        proof
          assume "t = to_nat_pm (snd z)"
          with \<open>d \<noteq> 0\<close> have "t \<notin> ?A" by (simp add: lookup_add c_def d_def)
          thus False using \<open>t \<in> ?A\<close> ..
        qed
        ultimately show "t \<in> ?B" by simp
      next
        have "to_nat_pm (fst z) \<in> keys ?f" by (simp add: keys_f)
        moreover from neq1 neq2 have "to_nat_pm (fst z) \<notin> keys ((- (c / d)) \<cdot> ?g)"
          by (simp add: keys_g')
        ultimately show "to_nat_pm (fst z) \<in> ?A" by (rule in_keys_plusI1)
      next
        have neq3: "to_nat_pm (snd (last zs)) \<noteq> to_nat_pm (snd z)"
        proof -
          from Cons.hyps(1) hd_in_set have "is_nat_pm_pair (hd zs)"
            by (rule vpc_is_nat_pm_pair) fact
          hence "is_nat_pm (fst (hd zs))" by (rule is_nat_pm_pairD)
          hence "of_nat_pm (to_nat_pm (fst (hd zs))) = fst (hd zs)" by (simp add: of_nat_pm_comp_to_nat_pm)
          hence "of_nat_pm (to_nat_pm (snd z)) \<noteq> (of_nat_pm (to_nat_pm (snd (last zs)))::_ \<Rightarrow>\<^sub>0 rat)"
            using False by (simp add: Cons.hyps(3) eq0)
          thus ?thesis by simp
        qed
        have "to_nat_pm (snd (last zs)) \<in> keys ((- (c / d)) \<cdot> ?g)" by (simp add: keys_g')
        moreover from neq1[symmetric] neq3 False have "to_nat_pm (snd (last zs)) \<notin> keys ?f"
          by (simp add: keys_f)
        ultimately show "to_nat_pm (snd (last zs)) \<in> ?A" by (rule in_keys_plusI2)
      qed
      finally show "of_nat_pm ` keys ((q1 + q1'') * f1 + (q2 + q2'') * f2) =
                      {fst (hd (z # zs)), snd (last (z # zs))}"
        using \<open>zs \<noteq> []\<close> by (simp add: eq_z eq0)
    next
      have "poly_deg ((q1 + q1'') * f1) = poly_deg (q1 * f1 + q1'' * f1)" by (simp only: algebra_simps)
      also have "\<dots> \<le> max (poly_deg (q1 * f1)) (poly_deg (q1'' * f1))" by (rule poly_deg_plus_le)
      also have "poly_deg (q1'' * f1) = poly_deg ((- (c / d)) \<cdot> (q1' * f1))"
        by (simp only: q1''_def map_scale_eq_times ac_simps)
      also from \<open>- (c / d) \<noteq> 0\<close> have "\<dots> = poly_deg (q1' * f1)" by (simp add: poly_deg_map_scale)
      finally have "rat (poly_deg ((q1 + q1'') * f1)) \<le>
                      max (rat (poly_deg (q1 * f1))) (rat (poly_deg (q1' * f1)))"
        by simp
      also from 1 3 have "\<dots> \<le> deg_vpc (z # zs)" by (rule max.boundedI)
      finally show "rat (poly_deg ((q1 + q1'') * f1)) \<le> deg_vpc (z # zs)" .
    next
      have "poly_deg ((q2 + q2'') * f2) = poly_deg (q2 * f2 + q2'' * f2)" by (simp only: algebra_simps)
      also have "\<dots> \<le> max (poly_deg (q2 * f2)) (poly_deg (q2'' * f2))" by (rule poly_deg_plus_le)
      also have "poly_deg (q2'' * f2) = poly_deg ((- (c / d)) \<cdot> (q2' * f2))"
        by (simp only: q2''_def map_scale_eq_times ac_simps)
      also from \<open>- (c / d) \<noteq> 0\<close> have "\<dots> = poly_deg (q2' * f2)" by (simp add: poly_deg_map_scale)
      finally have "rat (poly_deg ((q2 + q2'') * f2)) \<le>
                      max (rat (poly_deg (q2 * f2))) (rat (poly_deg (q2' * f2)))"
        by simp
      also from 2 4 have "\<dots> \<le> deg_vpc (z # zs)" by (rule max.boundedI)
      finally show "rat (poly_deg ((q2 + q2'') * f2)) \<le> deg_vpc (z # zs)" .
    qed
  qed
qed

definition min_length_vpc :: "('x point \<times> 'x point) list \<Rightarrow> bool"
  where "min_length_vpc zs \<longleftrightarrow> is_vpc zs \<and>
                   (\<forall>zs'. is_vpc zs' \<longrightarrow> fst (hd zs') = fst (hd zs) \<longrightarrow> snd (last zs') = snd (last zs) \<longrightarrow>
                          length zs \<le> length zs')"

definition min_vpc :: "('x point \<times> 'x point) list \<Rightarrow> bool"
  where "min_vpc zs \<longleftrightarrow> is_vpc zs \<and>
                   (\<forall>zs'. is_vpc zs' \<longrightarrow> fst (hd zs') = fst (hd zs) \<longrightarrow> snd (last zs') = snd (last zs) \<longrightarrow>
                          length zs < length zs' \<or> (length zs = length zs' \<and> deg_vpc zs \<le> deg_vpc zs'))"

lemma min_length_vpcI:
  "is_vpc zs \<Longrightarrow> (\<And>zs'. is_vpc zs' \<Longrightarrow> fst (hd zs') = fst (hd zs) \<Longrightarrow> snd (last zs') = snd (last zs) \<Longrightarrow>
          length zs \<le> length zs') \<Longrightarrow> min_length_vpc zs"
  by (simp add: min_length_vpc_def)

lemma min_length_vpcD:
  assumes "min_length_vpc zs"
  shows "is_vpc zs"
    and "is_vpc zs' \<Longrightarrow> fst (hd zs') = fst (hd zs) \<Longrightarrow> snd (last zs') = snd (last zs) \<Longrightarrow> length zs \<le> length zs'"
  using assms by (simp_all add: min_length_vpc_def)

lemma min_vpcI:
  "is_vpc zs \<Longrightarrow> (\<And>zs'. is_vpc zs' \<Longrightarrow> fst (hd zs') = fst (hd zs) \<Longrightarrow> snd (last zs') = snd (last zs) \<Longrightarrow>
          (length zs < length zs' \<or> (length zs = length zs' \<and> deg_vpc zs \<le> deg_vpc zs'))) \<Longrightarrow> min_vpc zs"
  by (simp add: min_vpc_def)

lemma min_vpcD:
  assumes "min_vpc zs"
  shows "is_vpc zs" and "min_length_vpc zs"
  using assms by (auto simp: min_length_vpc_def min_vpc_def)

lemma min_vpc_cases:
  assumes "min_vpc zs" and "is_vpc zs'" and "fst (hd zs') = fst (hd zs)" and "snd (last zs') = snd (last zs)"
  assumes "length zs < length zs' \<Longrightarrow> thesis"
  assumes "length zs = length zs' \<Longrightarrow> deg_vpc zs \<le> deg_vpc zs' \<Longrightarrow> thesis"
  shows thesis
  using assms by (auto simp: min_vpc_def)

lemma min_length_vpc_distinct:
  assumes "min_length_vpc zs"
  shows "distinct (map fst zs)" and "distinct (map snd zs)" and "distinct zs"
proof -
  from assms have "is_vpc zs" by (rule min_length_vpcD)

  show "distinct (map fst zs)"
  proof (intro distinctI notI)
    fix i j :: nat
    assume "i < j"
    assume "i < length (map fst zs)" and "j < length (map fst zs)"
    hence "i < length zs" and "j < length zs" by simp_all
    moreover assume "map fst zs ! i = map fst zs ! j"
    ultimately have "fst (zs ! i) = fst (zs ! j)" by simp
    with \<open>is_vpc zs\<close> \<open>i < j\<close> \<open>j < length zs\<close> obtain zs' where "is_vpc zs'"
      and "fst (hd zs') = fst (hd zs)" and "snd (last zs') = snd (last zs)"
      and eq: "length zs = length zs' + (j - i)" by (rule cut_vpc_fst)
    from assms this(1, 2, 3) have "length zs \<le> length zs'" by (rule min_length_vpcD)
    with \<open>i < j\<close> show False by (simp add: eq)
  qed

  show "distinct (map snd zs)"
  proof (intro distinctI notI)
    fix i j :: nat
    assume "i < j"
    assume "i < length (map snd zs)" and "j < length (map snd zs)"
    hence "i < length zs" and "j < length zs" by simp_all
    moreover assume "map snd zs ! i = map snd zs ! j"
    ultimately have "snd (zs ! i) = snd (zs ! j)" by simp
    with \<open>is_vpc zs\<close> \<open>i < j\<close> \<open>j < length zs\<close> obtain zs' where "is_vpc zs'"
      and "fst (hd zs') = fst (hd zs)" and "snd (last zs') = snd (last zs)"
      and eq: "length zs = length zs' + (j - i)" by (rule cut_vpc_snd)
    from assms this(1, 2, 3) have "length zs \<le> length zs'" by (rule min_length_vpcD)
    with \<open>i < j\<close> show False by (simp add: eq)
  qed

  thus "distinct zs" by (simp only: distinct_map)
qed

end

end (* two_polys *)

end (* theory *)
