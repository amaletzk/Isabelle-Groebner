section \<open>Valid Polygonial Chains\<close>

theory VPC
  imports Binomials Binom_Mult
begin

subsection \<open>Preliminaries\<close>

text \<open>Since most results in this theory are concerned with ideals generated by two polynomials, we
  prove some specific properties of such ideals.\<close>

lemma idealI_2: "q1 * f1 + q2 * f2 \<in> ideal {f1, f2::'a::comm_powerprod \<Rightarrow>\<^sub>0 'b::comm_ring_1}"
  by (rule ideal.span_add, rule ideal.span_scale, rule ideal.span_base,
      simp, rule ideal.span_scale, rule ideal.span_base, simp)

lemma idealE_2:
  assumes "f \<in> ideal {f1, f2}"
  obtains q1 q2 where "f = q1 * f1 + q2 * f2"
  using assms
proof (induct f arbitrary: thesis rule: ideal.span_induct')
  case base
  show ?case
  proof (rule base)
    show "0 = 0 * f1 + 0 * f2" by simp
  qed
next
  case (step f' c g)
  obtain q1 q2 where f'_eq: "f' = q1 * f1 + q2 * f2" by (rule step(2))
  from step(3) have "g = f1 \<or> g = f2" by simp
  thus ?case
  proof
    assume "g = f1"
    show ?case
    proof (rule step(5))
      show "f' + c * g = (q1 + c) * f1 + q2 * f2" by (simp add: f'_eq \<open>g = f1\<close> algebra_simps)
    qed
  next
    assume "g = f2"
    show ?case
    proof (rule step(5))
      show "f' + c * g = q1 * f1 + (q2 + c) * f2" by (simp add: f'_eq \<open>g = f2\<close> algebra_simps)
    qed
  qed
qed

lemma ideal_iff_2:
  "f \<in> ideal {f1, f2} \<longleftrightarrow> (\<exists>q1 q2. f = q1 * f1 + q2 * (f2::'a::comm_powerprod \<Rightarrow>\<^sub>0 'b::comm_ring_1))"
proof
  assume "f \<in> ideal {f1, f2}"
  then obtain q1 q2 where "f = q1 * f1 + q2 * f2" by (rule idealE_2)
  show "\<exists>q1 q2. f = q1 * f1 + q2 * f2" by (intro exI, fact)
next
  assume "\<exists>q1 q2. f = q1 * f1 + q2 * f2"
  then obtain q1 q2 where f_eq: "f = q1 * f1 + q2 * f2" by auto
  show "f \<in> ideal {f1, f2}" unfolding f_eq by (rule idealI_2)
qed

lemma map_scale_binomial:
  "a \<cdot> binomial c s d t = binomial (a * c) s (a * (d::_::semiring_0)) (t::_::comm_powerprod)"
  by (simp add: punit.map_scale_eq_monom_mult punit.monom_mult_binomial)

definition is_nat_pm_pair :: "(('x \<Rightarrow>\<^sub>0 'b) * ('x \<Rightarrow>\<^sub>0 'b::floor_ceiling)) \<Rightarrow> bool" where
  "is_nat_pm_pair pp = (is_nat_pm (fst pp) \<and> is_nat_pm (snd pp))"

definition is_int_pm_pair :: "(('x \<Rightarrow>\<^sub>0 'b) * ('x \<Rightarrow>\<^sub>0 'b::floor_ceiling)) \<Rightarrow> bool" where
  "is_int_pm_pair pp = (is_int_pm (fst pp) \<and> is_int_pm (snd pp))"
  
lemma is_nat_pm_pairI: "is_nat_pm (fst pp) \<Longrightarrow> is_nat_pm (snd pp) \<Longrightarrow> is_nat_pm_pair pp"
  unfolding is_nat_pm_pair_def ..
    
lemma is_nat_pm_pairD:
  assumes "is_nat_pm_pair pp"
  shows "is_nat_pm (fst pp)" and "is_nat_pm (snd pp)"
  using assms by (simp_all add: is_nat_pm_pair_def)

lemma is_int_pm_pairI: "is_int_pm (fst pp) \<Longrightarrow> is_int_pm (snd pp) \<Longrightarrow> is_int_pm_pair pp"
  unfolding is_int_pm_pair_def ..
    
lemma is_int_pm_pairD:
  assumes "is_int_pm_pair pp"
  shows "is_int_pm (fst pp)" and "is_int_pm (snd pp)"
  using assms by (simp_all add: is_int_pm_pair_def)
    
lemma nat_pm_pair_is_int_pm_pair: "is_nat_pm_pair pp \<Longrightarrow> is_int_pm_pair pp"
  by (auto intro: is_int_pm_pairI dest: is_nat_pm_pairD nat_pm_is_int_pm)

abbreviation "rat \<equiv> rat_of_nat"

type_synonym 'x point = "('x \<Rightarrow>\<^sub>0 rat)"

definition deg_pair :: "('x point \<times> 'x point) \<Rightarrow> rat"
  where "deg_pair pp = max (deg_pm (fst pp)) (deg_pm (snd pp))"

context pm_powerprod
begin

lemma binomial_lp_in_ideal_iff:
  assumes "f \<in> ideal F" and "is_binomial f"
  shows "monomial 1 (lp f) \<in> ideal F \<longleftrightarrow> monomial (1::_::field) (tp f) \<in> ideal F"
proof (cases "is_monomial f")
  case True
  hence "lp f = tp f" by (rule punit.lt_eq_tt_monomial)
  thus ?thesis by simp
next
  case False
  with assms(2) have "is_proper_binomial f" by (simp add: is_binomial_alt)
  hence "tp f \<prec> lp f" by (rule punit.lt_gr_tt_binomial)
  hence "lp f \<noteq> tp f" by simp
  from assms(2) have "keys f = {lp f, tp f}" by (rule punit.keys_binomial)
  moreover have "monomial 1 u \<in> ideal F" if "monomial 1 v \<in> ideal F" and "keys f = {u, v}" for u v
  proof -
    from \<open>keys f = {lp f, tp f}\<close> that(2) \<open>lp f \<noteq> tp f\<close> have "u \<noteq> v" by auto
    hence "monomial (lookup f u) u + monomial (lookup f v) v = f"
      by (auto intro!: poly_mapping_eqI simp: lookup_add lookup_single when_def \<open>keys f = {u, v}\<close>)
    moreover define c where "c = lookup f u"
    moreover define d where "d = lookup f v"
    ultimately have f: "f = monomial c u + punit.monom_mult d 0 (monomial 1 v)"
      by (simp add: punit.monom_mult_monomial)
    from that(1) have "punit.monom_mult d 0 (monomial 1 v) \<in> ideal F"
      by (rule punit.pmdl_closed_monom_mult[simplified])
    with assms(1) have "f - punit.monom_mult d 0 (monomial 1 v) \<in> ideal F" by (rule ideal.span_diff)
    hence "monomial c u \<in> ideal F" by (simp add: f)
    hence "punit.monom_mult (1 / c) 0 (monomial c u) \<in> ideal F"
      by (rule punit.pmdl_closed_monom_mult[simplified])
    moreover have "c \<noteq> 0" by (simp add: c_def \<open>keys f = {u, v}\<close>)
    ultimately show ?thesis by (simp add: punit.monom_mult_monomial)
  qed
  ultimately show ?thesis by blast
qed

lemma map_scale_mono:
  assumes "m \<le> n"
  shows "m \<cdot> t \<preceq> n \<cdot> t"
proof -
  have "m \<cdot> t \<preceq> m \<cdot> t + (n - m) \<cdot> t" using zero_min plus_monotone_left by fastforce
  also have "\<dots> = (m + (n - m)) \<cdot> t" by (simp only: map_scale_distrib_right)
  also from assms have "\<dots> = n \<cdot> t" by simp
  finally show ?thesis .
qed

lemma map_scale_mono_left:
  assumes "s \<preceq> t"
  shows "m \<cdot> s \<preceq> m \<cdot> t"
proof (induct m)
  case 0
  show ?case by simp
next
  case (Suc m)
  have "Suc m \<cdot> s = (m + 1) \<cdot> s" by simp
  also have "\<dots> = m \<cdot> s + s" by (simp only: map_scale_distrib_right map_scale_one_left)
  also from Suc have "\<dots> \<preceq> m \<cdot> t + s" by (rule plus_monotone)
  also from assms have "\<dots> \<preceq> m \<cdot> t + t" by (rule plus_monotone_left)
  also have "\<dots> = (m + 1) \<cdot> t" by (simp only: map_scale_distrib_right map_scale_one_left)
  also have "\<dots> = Suc m \<cdot> t" by simp
  finally show ?case .
qed

lemma map_scale_mono_strict:
  assumes "m < n" and "t \<noteq> 0"
  shows "m \<cdot> t \<prec> n \<cdot> t"
proof -
  from assms(1) have "m \<le> n" by simp
  hence "m \<cdot> t \<preceq> n \<cdot> t" by (rule map_scale_mono)
  moreover have "m \<cdot> t \<noteq> n \<cdot> t"
  proof
    from assms(2) obtain x where "0 < lookup t x" using aux by auto
    assume "m \<cdot> t = n \<cdot> t"
    hence "lookup (m \<cdot> t) x = lookup (n \<cdot> t) x" by simp
    with \<open>0 < lookup t x\<close> assms(1) show False by simp
  qed
  ultimately show ?thesis by simp
qed

lemma map_scale_mono_strict_left:
  assumes "s \<prec> t" and "0 < m"
  shows "m \<cdot> s \<prec> m \<cdot> t"
proof -
  from assms(1) have "s \<preceq> t" by simp
  hence "m \<cdot> s \<preceq> m \<cdot> t" by (rule map_scale_mono_left)
  moreover have "m \<cdot> s \<noteq> m \<cdot> t"
  proof
    from assms(1) have "s \<noteq> t" by simp
    then obtain x where "lookup s x \<noteq> lookup t x" by (meson poly_mapping_eqI)
    with assms(2) have "lookup (m \<cdot> s) x \<noteq> lookup (m \<cdot> t) x" by simp
    moreover assume "m \<cdot> s = m \<cdot> t"
    ultimately show False by simp
  qed
  ultimately show ?thesis by simp
qed

definition poly_point :: "(('x \<Rightarrow>\<^sub>0 nat) \<Rightarrow>\<^sub>0 'b::zero) \<Rightarrow> ('x point \<times> 'x point)" where
  "poly_point p = (of_nat_pm (lp p), of_nat_pm (tp p))"

definition vect :: "(('x \<Rightarrow>\<^sub>0 nat) \<Rightarrow>\<^sub>0 'b::zero) \<Rightarrow> ('x point)"
  where "vect p = fst (poly_point p) - snd (poly_point p)"

lemma fst_poly_point: "fst (poly_point p) = of_nat_pm (lp p)"
  by (simp add: poly_point_def)
    
lemma snd_poly_point: "snd (poly_point p) = of_nat_pm (tp p)"
  by (simp add: poly_point_def)

lemma poly_point_is_nat_pm_pair: "is_nat_pm_pair (poly_point p)"
  unfolding poly_point_def by (rule is_nat_pm_pairI, simp_all, (rule of_nat_pm_is_nat_pm)+)

lemma poly_point_is_int_pm_pair: "is_int_pm_pair (poly_point p)"
  using poly_point_is_nat_pm_pair by (rule nat_pm_pair_is_int_pm_pair)

lemma swap_poly_point_not_eq:
  assumes "is_proper_binomial p"
  shows "prod.swap (poly_point p) \<noteq> poly_point q"
proof
  assume "prod.swap (poly_point p) = poly_point q"
  hence 1: "lp p = tp q" and 2: "tp p = lp q" by (simp_all add: poly_point_def)
  from assms(1) have "tp p \<prec> lp p" by (rule punit.lt_gr_tt_binomial)
  hence "lp q \<prec> tp q" by (simp only: 1 2)
  with punit.lt_ge_tt[of q] show False by simp
qed

corollary swap_poly_point_not_eq':
  assumes "is_proper_binomial q"
  shows "prod.swap (poly_point p) \<noteq> poly_point q"
proof
  assume *: "prod.swap (poly_point p) = poly_point q"
  from assms have "prod.swap (poly_point q) \<noteq> poly_point p" by (rule swap_poly_point_not_eq)
  moreover from *[symmetric] have "prod.swap (poly_point q) = poly_point p" by simp
  ultimately show False ..
qed

lemma vect_alt: "vect p = of_nat_pm (lp p) - of_nat_pm (tp p)"
  by (simp only: vect_def fst_poly_point snd_poly_point)

lemma vect_is_int_pm: "is_int_pm (vect p)"
  by (simp add: vect_def is_int_pm_pairD[OF poly_point_is_int_pm_pair] is_int_pm_pairD minus_is_int_pm)

end

locale two_polys =
  pm_powerprod ord ord_strict
  for ord::"('x \<Rightarrow>\<^sub>0 nat) \<Rightarrow> ('x::{countable,linorder} \<Rightarrow>\<^sub>0 nat) \<Rightarrow> bool" (infixl "\<preceq>" 50)
  and ord_strict (infixl "\<prec>" 50) +
  fixes f1 f2 :: "('x \<Rightarrow>\<^sub>0 nat) \<Rightarrow>\<^sub>0 'b::field"
begin

definition overlap :: "'x point"
  where "overlap = lcs (gcs (fst (poly_point f1)) (snd (poly_point f1)))
                       (gcs (fst (poly_point f2)) (snd (poly_point f2)))"

lemma overlap_alt:
  "overlap = lcs (gcs (of_nat_pm (lp f1)) (of_nat_pm (tp f1)))
                 (gcs (of_nat_pm (lp f2)) (of_nat_pm (tp f2)))"
  by (simp only: overlap_def fst_poly_point snd_poly_point)

lemma overlap_alt': "overlap = of_nat_pm (lcs (gcs (lp f1) (tp f1)) (gcs (lp f2) (tp f2)))"
  by (simp add: overlap_alt gcs_of_nat_pm lcs_of_nat_pm)

lemma overlap_is_nat_pm: "is_nat_pm overlap"
  by (simp add: overlap_def is_nat_pm_pairD[OF poly_point_is_nat_pm_pair] gcs_is_nat_pm lcs_is_nat_pm)

lemma gcs_le_overlap:
  shows "gcs (of_nat_pm (lp f1)) (of_nat_pm (tp f1)) \<unlhd> overlap"
    and "gcs (of_nat_pm (lp f2)) (of_nat_pm (tp f2)) \<unlhd> overlap"
  by (simp_all add: overlap_alt le_pm_def lookup_lcs_fun leq_lcs_fun_1 leq_lcs_fun_2)

lemma gcs_le_overlap':
  shows "of_nat_pm (gcs (lp f1) (tp f1)) \<unlhd> overlap" and "of_nat_pm (gcs (lp f2) (tp f2)) \<unlhd> overlap"
  using gcs_le_overlap by (simp_all add: gcs_of_nat_pm)

lemma overlap_is_int_pm: "is_int_pm overlap"
  using overlap_is_nat_pm by (rule nat_pm_is_int_pm)

lemma lem_3_1_13:
  assumes "of_nat_pm (tp f1) \<unlhd> p" and "of_nat_pm (tp f2) \<unlhd> p"
  shows "overlap \<unlhd> p"
  unfolding overlap_alt lookup_lcs_fun le_pm_def
proof (rule lcs_leq_fun)
  let ?t = "of_nat_pm (lp f1)"
  let ?s = "of_nat_pm (tp f1)"
  have "lookup (gcs ?t ?s) \<le> lookup ?s" unfolding lookup_gcs_fun by (fact gcs_leq_fun_2)
  also from assms(1) have "... \<le> lookup p" by (simp only: le_pm_def)
  finally show "lookup (gcs ?t ?s) \<le> lookup p" .
next
  let ?t = "of_nat_pm (lp f2)"
  let ?s = "of_nat_pm (tp f2)"
  have "lookup (gcs ?t ?s) \<le> lookup ?s" unfolding lookup_gcs_fun by (fact gcs_leq_fun_2)
  also from assms(2) have "... \<le> lookup p" by (simp only: le_pm_def)
  finally show "lookup (gcs ?t ?s) \<le> lookup p" .
qed

subsection \<open>VPCs\<close>

definition shifts :: "('x point \<times> 'x point) set"
  where "shifts = (let A = {poly_point f1, poly_point f2} in A \<union> prod.swap ` A)"

lemma shiftsI1: "s = poly_point f1 \<Longrightarrow> s \<in> shifts"
  by (simp add: shifts_def)

lemma shiftsI2: "s = poly_point f2 \<Longrightarrow> s \<in> shifts"
  by (simp add: shifts_def)

lemma shiftsI3: "s = prod.swap (poly_point f1) \<Longrightarrow> s \<in> shifts"
  by (simp add: shifts_def)

lemma shiftsI4: "s = prod.swap (poly_point f2) \<Longrightarrow> s \<in> shifts"
  by (simp add: shifts_def)

lemma shiftsI:
  assumes "f \<in> {f1, f2}"
  shows "poly_point f \<in> shifts" and "prod.swap (poly_point f) \<in> shifts"
  using assms by (auto intro: shiftsI1 shiftsI2 shiftsI3 shiftsI4)

lemma shiftsE:
  assumes "s \<in> shifts"
  obtains "s = poly_point f1" | "s = poly_point f2" |
          "s = prod.swap (poly_point f1)" | "s = prod.swap (poly_point f2)"
  using assms by (auto simp: shifts_def)

definition nat_plus_point_pair :: "('x \<Rightarrow>\<^sub>0 nat) \<Rightarrow> ('x point \<times> 'x point) \<Rightarrow> ('x point \<times> 'x point)" (infixl "+\<^sub>N" 70)
  where "nat_plus_point_pair t pp = (of_nat_pm t + fst pp, of_nat_pm t + snd pp)"

abbreviation "Nshifts \<equiv> case_prod (+\<^sub>N) ` (UNIV \<times> shifts)"

lemma Nshifts_eqI: "z = t +\<^sub>N s \<Longrightarrow> s \<in> shifts \<Longrightarrow> z \<in> Nshifts"
  by blast

lemma NshiftsI: "s \<in> shifts \<Longrightarrow> t +\<^sub>N s \<in> Nshifts"
  by blast

lemma NshiftsE:
  assumes "z \<in> Nshifts"
  obtains t s where "s \<in> shifts" and "z = t +\<^sub>N s"
  using assms by auto

definition is_vpc :: "('x point \<times> 'x point) list \<Rightarrow> bool"
  where "is_vpc zs \<longleftrightarrow> zs \<noteq> [] \<and> (\<forall>i<length zs - 1. snd (zs ! i) = fst (zs ! Suc i)) \<and>
                      set zs \<subseteq> Nshifts"

lemma is_vpcI:
  "zs \<noteq> [] \<Longrightarrow> (\<And>i. Suc i < length zs \<Longrightarrow> snd (zs ! i) = fst (zs ! Suc i)) \<Longrightarrow> set zs \<subseteq> Nshifts \<Longrightarrow>
    is_vpc zs"
  by (simp add: is_vpc_def)

lemma is_vpcD:
  assumes "is_vpc zs"
  shows "zs \<noteq> []" and "Suc i < length zs \<Longrightarrow> snd (zs ! i) = fst (zs ! Suc i)" and "set zs \<subseteq> Nshifts"
  using assms by (simp_all add: is_vpc_def)

lemma is_vpcE:
  assumes "is_vpc zs" and "z \<in> set zs"
  obtains t s where "s \<in> shifts" and "z = t +\<^sub>N s"
  using assms by (auto dest!: is_vpcD(3))

lemma is_vpc_takeI: "is_vpc zs \<Longrightarrow> 0 < n \<Longrightarrow> is_vpc (take n zs)"
  using set_take_subset[of n zs] by (auto intro!: is_vpcI dest: is_vpcD)

lemma is_vpc_dropI:
  assumes "is_vpc zs" and "n < length zs"
  shows "is_vpc (drop n zs)"
proof (rule is_vpcI)
  from assms(2) show "drop n zs \<noteq> []" by simp
next
  fix i
  assume "Suc i < length (drop n zs)"
  with assms(2) have *: "Suc (n + i) < length zs" by simp
  from assms(2) have "snd (drop n zs ! i) = snd (zs ! (n + i))" by simp
  also from assms(1) * have "\<dots> = fst (zs ! Suc (n + i))" by (rule is_vpcD)
  also from assms(2) have "\<dots> = fst (drop n zs ! Suc i)" by simp
  finally show "snd (drop n zs ! i) = fst (drop n zs ! Suc i)" .
next
  from assms(1) have "set zs \<subseteq> Nshifts" by (rule is_vpcD)
  with set_drop_subset show "set (drop n zs) \<subseteq> Nshifts" by (rule subset_trans)
qed

lemma is_vpc_singleton [simp]: "is_vpc [z] \<longleftrightarrow> z \<in> Nshifts"
  by (simp add: is_vpc_def)

lemma is_vpc_appendI:
  assumes "is_vpc zs1" and "is_vpc zs2" and "snd (last zs1) = fst (hd zs2)"
  shows "is_vpc (zs1 @ zs2)"
proof (rule is_vpcI)
  from assms(2) have "zs2 \<noteq> []" by (rule is_vpcD)
  from assms(1) have "zs1 \<noteq> []" by (rule is_vpcD)
  thus "zs1 @ zs2 \<noteq> []" by simp

  fix i
  assume 1: "Suc i < length (zs1 @ zs2)"
  show "snd ((zs1 @ zs2) ! i) = fst ((zs1 @ zs2) ! Suc i)"
  proof (rule linorder_cases)
    assume 2: "Suc i < length zs1"
    with assms(1) have "snd (zs1 ! i) = fst (zs1 ! Suc i)" by (rule is_vpcD)
    with 2 show ?thesis by (simp add: nth_append)
  next
    assume 2: "Suc i = length zs1"
    hence 3: "i = length zs1 - 1" and "i < length zs1" by simp_all
    have "snd ((zs1 @ zs2) ! i) = snd (zs1 ! i)" by (simp add: nth_append \<open>i < length zs1\<close>)
    also from \<open>zs1 \<noteq> []\<close> have "\<dots> = snd (last zs1)" by (simp add: last_conv_nth 3)
    also have "\<dots> = fst (hd zs2)" by fact
    also from \<open>zs2 \<noteq> []\<close> have "\<dots> = fst (zs2 ! 0)" by (simp add: hd_conv_nth)
    also have "\<dots> = fst ((zs1 @ zs2) ! (Suc i))" by (simp add: nth_append 2)
    finally show ?thesis .
  next
    assume 2: "length zs1 < Suc i"
    with 1 have "Suc (i - length zs1) < length zs2" by simp
    with assms(2) have "snd (zs2 ! (i - length zs1)) = fst (zs2 ! Suc (i - length zs1))" by (rule is_vpcD)
    with 2 show ?thesis by (simp add: nth_append Suc_diff_le)
  qed
next
  from assms(1) have "set zs1 \<subseteq> Nshifts" by (rule is_vpcD)
  moreover from assms(2) have "set zs2 \<subseteq> Nshifts" by (rule is_vpcD)
  ultimately show "set (zs1 @ zs2) \<subseteq> Nshifts" by simp
qed

lemma is_vpc_ConsI:
  assumes "is_vpc zs" and "z \<in> Nshifts" and "snd z = fst (hd zs)"
  shows "is_vpc (z # zs)"
proof -
  have "is_vpc ([z] @ zs)" by (rule is_vpc_appendI) (simp_all add: assms)
  thus ?thesis by simp
qed

context
  assumes f1_pbinomial: "is_proper_binomial f1"
  assumes f2_pbinomial: "is_proper_binomial f2"
begin

text \<open>If VPCs were defined w.r.t. arbitrary sets of polynomials, the following lemma could most
  probably be proved for arbitrary sets of proper binomials.\<close>

lemma vpcE_ideal:
  assumes "f \<in> ideal {f1, f2}" and "is_proper_binomial f" and "monomial 1 (lp f) \<notin> ideal {f1, f2}"
  obtains zs where "is_vpc zs" and "fst (hd zs) = of_nat_pm (lp f)" and "snd (last zs) = of_nat_pm (tp f)"
proof -
  let ?l = "of_nat_pm (lp f)"
  define F where "F = {f1, f2}"
  have "finite F" by (simp add: F_def)
  moreover from assms(1) have "f \<in> ideal F" by (simp only: F_def)
  ultimately obtain q where f: "f = (\<Sum>f0\<in>F. q f0 * f0)" by (rule ideal.span_finiteE)
  from assms(2) have keys_f: "keys f = {lp f, tp f}" by (rule punit.keys_proper_binomial)
  define Y where "Y = (\<lambda>f0. {t \<in> keys (q f0). \<exists>zs. is_vpc zs \<and> fst (hd zs) = ?l \<and>
                            (t +\<^sub>N poly_point f0 \<in> set zs \<or> t +\<^sub>N prod.swap (poly_point f0) \<in> set zs)})"
  define q' where "q' = (\<lambda>f0. except (q f0) (- Y f0))"
  define q'' where "q'' = (\<lambda>f0. except (q f0) (Y f0))"
  have "Y f0 \<subseteq> keys (q f0)" for f0 by (simp add: Y_def)
  hence keys_q': "keys (q' f0) = Y f0" for f0 by (simp add: q'_def keys_except Int_absorb1)
  let ?f = "(\<Sum>f0\<in>F. q' f0 * f0)"
  have vpcE: thesis0
    if "t \<in> keys ?f" and "\<And>zs. is_vpc zs \<Longrightarrow> fst (hd zs) = ?l \<Longrightarrow> snd (last zs) = of_nat_pm t \<Longrightarrow> thesis0"
    for thesis0 t
  proof -
    have "keys ?f \<subseteq> (\<Union>f0\<in>F. keys (q' f0 * f0))" by (rule keys_sum_subset)
    with that(1) have "t \<in> (\<Union>f0\<in>F. keys (q' f0 * f0))" ..
    thus ?thesis
    proof
      fix f0
      assume "f0 \<in> F"
      hence "f0 = f1 \<or> f0 = f2" by (simp add: F_def)
      with f1_pbinomial f2_pbinomial have "is_proper_binomial f0" by blast
      hence keys_f0: "keys f0 = {lp f0, tp f0}" by (rule punit.keys_proper_binomial)
      assume "t \<in> keys (q' f0 * f0)"
      then obtain s u where "s \<in> keys (q' f0)" and "u \<in> keys f0" and t: "t = s + u"
        by (rule in_keys_timesE)
      from this(2) have u_cases: "u = lp f0 \<or> u = tp f0" by (simp add: keys_f0)
      from \<open>s \<in> keys (q' f0)\<close> obtain zs where "is_vpc zs" and eq1: "fst (hd zs) = ?l"
        and "s +\<^sub>N poly_point f0 \<in> set zs \<or> s +\<^sub>N prod.swap (poly_point f0) \<in> set zs"
        unfolding keys_q' Y_def by blast
      from this(3) show ?thesis
      proof
        assume "s +\<^sub>N poly_point f0 \<in> set zs"
        then obtain i where "i < length zs" and eq2: "zs ! i = s +\<^sub>N poly_point f0"
          by (meson in_set_conv_nth)
        let ?zs = "take (Suc i) zs"
        from \<open>is_vpc zs\<close> have "is_vpc ?zs" by (rule is_vpc_takeI) simp
        have eq3: "fst (hd ?zs) = ?l" by (simp add: eq1)
        from \<open>i < length zs\<close> have eq4: "last ?zs = s +\<^sub>N poly_point f0" and "?zs \<noteq> []"
          by (auto simp: last_take_conv_nth eq2)
        from u_cases show ?thesis
        proof
          assume u: "u = lp f0"
          let ?ys = "?zs @ [s +\<^sub>N prod.swap (poly_point f0)]"
          from \<open>is_vpc ?zs\<close> have "is_vpc ?ys"
          proof (rule is_vpc_appendI)
            from \<open>f0 \<in> F\<close> show "is_vpc [s +\<^sub>N prod.swap (poly_point f0)]"
              by (auto simp: F_def intro: NshiftsI shiftsI)
          qed (simp add: eq4 nat_plus_point_pair_def)
          moreover from \<open>?zs \<noteq> []\<close> have "fst (hd ?ys) = ?l" by (simp add: eq1)
          moreover from \<open>i < length zs\<close> have "snd (last ?ys) = of_nat_pm t"
            by (simp add: nat_plus_point_pair_def t u fst_poly_point of_nat_pm_plus)
          ultimately show ?thesis by (rule that(2))
        next
          assume "u = tp f0"
          hence "snd (last ?zs) = of_nat_pm t"
            by (simp add: eq4 nat_plus_point_pair_def snd_poly_point t of_nat_pm_plus)
          with \<open>is_vpc ?zs\<close> eq3 show ?thesis by (rule that(2))
        qed
      next
        assume "s +\<^sub>N prod.swap (poly_point f0) \<in> set zs"
        then obtain i where "i < length zs" and eq2: "zs ! i = s +\<^sub>N prod.swap (poly_point f0)"
          by (meson in_set_conv_nth)
        let ?zs = "take (Suc i) zs"
        from \<open>is_vpc zs\<close> have "is_vpc ?zs" by (rule is_vpc_takeI) simp
        have eq3: "fst (hd ?zs) = ?l" by (simp add: eq1)
        from \<open>i < length zs\<close> have eq4: "last ?zs = s +\<^sub>N prod.swap (poly_point f0)" and "?zs \<noteq> []"
          by (auto simp: last_take_conv_nth eq2)
        from u_cases show ?thesis
        proof
          assume u: "u = tp f0"
          let ?ys = "?zs @ [s +\<^sub>N poly_point f0]"
          from \<open>is_vpc ?zs\<close> have "is_vpc ?ys"
          proof (rule is_vpc_appendI)
            from \<open>f0 \<in> F\<close> show "is_vpc [s +\<^sub>N poly_point f0]"
              by (auto simp: F_def intro: NshiftsI shiftsI)
          qed (simp add: eq4 nat_plus_point_pair_def)
          moreover from \<open>?zs \<noteq> []\<close> have "fst (hd ?ys) = ?l" by (simp add: eq1)
          moreover from \<open>i < length zs\<close> have "snd (last ?ys) = of_nat_pm t"
            by (simp add: nat_plus_point_pair_def t u snd_poly_point of_nat_pm_plus)
          ultimately show ?thesis by (rule that(2))
        next
          assume "u = lp f0"
          hence "snd (last ?zs) = of_nat_pm t"
            by (simp add: eq4 nat_plus_point_pair_def fst_poly_point t of_nat_pm_plus)
          with \<open>is_vpc ?zs\<close> eq3 show ?thesis by (rule that(2))
        qed
      qed
    qed
  qed
  have "f = (\<Sum>f0\<in>F. (q'' f0 + q' f0) * f0)" by (simp only: q''_def q'_def f flip: except_decomp)
  also have "\<dots> = (\<Sum>f0\<in>F. q'' f0 * f0) + ?f" (is "_ = ?g + _") by (simp add: algebra_simps sum.distrib)
  finally have f': "f = ?g + ?f" .
  have 1: "t \<notin> keys ?g" if "is_vpc zs" and "fst (hd zs) = ?l" and "snd (last zs) = of_nat_pm t" for t zs
  proof
    from that(1) have "zs \<noteq> []" by (rule is_vpcD)
    assume "t \<in> keys ?g"
    also have "\<dots> \<subseteq> (\<Union>f0\<in>F. keys (q'' f0 * f0))" by (rule keys_sum_subset)
    finally have "t \<in> (\<Union>f0\<in>F. keys (q'' f0 * f0))" .
    thus False
    proof
      fix f0
      assume "f0 \<in> F"
      hence "f0 = f1 \<or> f0 = f2" by (simp add: F_def)
      with f1_pbinomial f2_pbinomial have "is_proper_binomial f0" by blast
      hence keys_f0: "keys f0 = {lp f0, tp f0}" by (rule punit.keys_proper_binomial)
      assume "t \<in> keys (q'' f0 * f0)"
      then obtain s u where "s \<in> keys (q'' f0)" and "u \<in> keys f0" and t: "t = s + u"
        by (rule in_keys_timesE)
      have "keys (q'' f0) \<subseteq> keys (q f0)" by (simp add: q''_def keys_except)
      with \<open>s \<in> keys (q'' f0)\<close> have "s \<in> keys (q f0)" ..
      from \<open>u \<in> keys f0\<close> have u_cases: "u = lp f0 \<or> u = tp f0" by (simp add: keys_f0)
      thus ?thesis
      proof
        assume u: "u = lp f0"
        let ?zs = "zs @ [s +\<^sub>N poly_point f0]"
        from \<open>is_vpc zs\<close> have "is_vpc ?zs"
        proof (rule is_vpc_appendI)
          from \<open>f0 \<in> F\<close> show "is_vpc [s +\<^sub>N poly_point f0]"
            by (auto simp: F_def intro: NshiftsI shiftsI)
        qed (simp add: that(3) nat_plus_point_pair_def fst_poly_point t u of_nat_pm_plus)
        moreover from \<open>zs \<noteq> []\<close> have "fst (hd ?zs) = ?l" by (simp add: that(2))
        ultimately have "s \<in> Y f0" using \<open>s \<in> keys (q f0)\<close> by (auto simp: Y_def)
        hence "s \<notin> keys (q'' f0)" by (simp add: q''_def keys_except)
        thus ?thesis using \<open>s \<in> keys (q'' f0)\<close> ..
      next
        assume u: "u = tp f0"
        let ?zs = "zs @ [s +\<^sub>N prod.swap (poly_point f0)]"
        from \<open>is_vpc zs\<close> have "is_vpc ?zs"
        proof (rule is_vpc_appendI)
          from \<open>f0 \<in> F\<close> show "is_vpc [s +\<^sub>N prod.swap (poly_point f0)]"
            by (auto simp: F_def intro: NshiftsI shiftsI)
        qed (simp add: that(3) nat_plus_point_pair_def snd_poly_point t u of_nat_pm_plus)
        moreover from \<open>zs \<noteq> []\<close> have "fst (hd ?zs) = ?l" by (simp add: that(2))
        ultimately have "s \<in> Y f0" using \<open>s \<in> keys (q f0)\<close> by (auto simp: Y_def)
        hence "s \<notin> keys (q'' f0)" by (simp add: q''_def keys_except)
        thus ?thesis using \<open>s \<in> keys (q'' f0)\<close> ..
      qed
    qed
  qed
  have disjnt: "keys ?g \<inter> keys ?f = {}"
  proof (intro subset_antisym subsetI)
    fix t
    assume "t \<in> keys ?g \<inter> keys ?f"
    hence "t \<in> keys ?g" and "t \<in> keys ?f" by simp_all
    from this(2) obtain zs where "is_vpc zs" and "fst (hd zs) = ?l"
      and "snd (last zs) = of_nat_pm t" by (rule vpcE)
    hence "t \<notin> keys ?g" by (rule 1)
    thus "t \<in> {}" using \<open>t \<in> keys ?g\<close> ..
  qed simp
  hence "keys ?g \<union> keys ?f = keys (?g + ?f)" by (rule keys_add)
  also have "\<dots> = {lp f, tp f}" by (simp only: keys_f flip: f')
  finally have *: "keys ?g \<union> keys ?f = {lp f, tp f}" .
  moreover have "lp f \<notin> keys ?g"
  proof -
    have "lp f \<in> keys f" by (simp add: keys_f)
    also have "\<dots> \<subseteq> (\<Union>f0\<in>F. keys (q f0 * f0))" unfolding f by (rule keys_sum_subset)
    finally obtain f0 where "f0 \<in> F" and "lp f \<in> keys (q f0 * f0)" ..
    from this(2) obtain s u where "s \<in> keys (q f0)" and "u \<in> keys f0" and lp: "lp f = s + u"
      by (rule in_keys_timesE)
    from \<open>f0 \<in> F\<close> have f0_cases: "f0 = f1 \<or> f0 = f2" by (simp add: F_def)
    with f1_pbinomial f2_pbinomial have "is_proper_binomial f0" by blast
    hence "keys f0 = {lp f0, tp f0}" by (rule punit.keys_proper_binomial)
    with \<open>u \<in> keys f0\<close> have "u = lp f0 \<or> u = tp f0" by simp
    thus ?thesis
    proof
      assume u: "u = lp f0"
      let ?zs = "[s +\<^sub>N poly_point f0, s +\<^sub>N prod.swap (poly_point f0)]"
      have "is_vpc ?zs"
      proof (rule is_vpc_ConsI)
        from \<open>f0 \<in> F\<close> show "is_vpc [s +\<^sub>N prod.swap (poly_point f0)]"
          by (auto simp: F_def intro: NshiftsI shiftsI)
      next
        from \<open>f0 \<in> F\<close> show "s +\<^sub>N poly_point f0 \<in> Nshifts" unfolding F_def by (intro NshiftsI shiftsI)
      qed (simp add: nat_plus_point_pair_def)
      moreover have "fst (hd ?zs) = of_nat_pm (lp f)" and "snd (last ?zs) = of_nat_pm (lp f)"
        by (simp_all add: nat_plus_point_pair_def poly_point_def lp u of_nat_pm_plus)
      ultimately show ?thesis by (rule 1)
    next
      assume u: "u = tp f0"
      let ?zs = "[s +\<^sub>N prod.swap (poly_point f0), s +\<^sub>N poly_point f0]"
      have "is_vpc ?zs"
      proof (rule is_vpc_ConsI)
        from \<open>f0 \<in> F\<close> show "is_vpc [s +\<^sub>N poly_point f0]"
          by (auto simp: F_def intro: NshiftsI shiftsI)
      next
        from \<open>f0 \<in> F\<close> show "s +\<^sub>N prod.swap (poly_point f0) \<in> Nshifts"
          unfolding F_def by (intro NshiftsI shiftsI)
      qed (simp add: nat_plus_point_pair_def)
      moreover have "fst (hd ?zs) = of_nat_pm (lp f)" and "snd (last ?zs) = of_nat_pm (lp f)"
        by (simp_all add: nat_plus_point_pair_def poly_point_def lp u of_nat_pm_plus)
      ultimately show ?thesis by (rule 1)
    qed
  qed
  ultimately have "lp f \<in> keys ?f" by blast
  have "tp f \<in> keys ?f"
  proof (rule ccontr)
    assume "tp f \<notin> keys ?f"
    with \<open>lp f \<in> keys ?f\<close> * have keys_f': "keys ?f = {lp f}" by blast
    moreover define c where "c = lookup ?f (lp f)"
    ultimately have "monomial c (lp f) = ?f"
      by (auto intro!: poly_mapping_eqI simp: lookup_single when_def)
    also have "\<dots> \<in> ideal F" by (rule ideal.sum_in_spanI)
    finally have "monomial (1 / c) 0 * monomial c (lp f) \<in> ideal F" by (rule ideal.span_scale)
    moreover have "c \<noteq> 0" by (simp add: c_def keys_f')
    ultimately have "monomial 1 (lp f) \<in> ideal {f1, f2}" by (simp add: times_monomial_monomial F_def)
    with assms(3) show False ..
  qed
  then obtain zs where "is_vpc zs" and "fst (hd zs) = ?l" and "snd (last zs) = of_nat_pm (tp f)"
    by (rule vpcE)
  thus ?thesis ..
qed

text \<open>Lemma \<open>vpcE_ideal\<close> corresponds to Theorem 3.3.14 in @{cite "MWW2015"}. There, however, it is
  proved quite differently, relying on the fairly complicated Lemma 3.3.11. The proof of this lemma
  contains a substantial gap which, intuitively, could be closed, but I have no idea how to do it
  rigorously. That is the reason for the different approach here.\<close>

definition deg_vpc :: "('x point \<times> 'x point) list \<Rightarrow> rat"
  where "deg_vpc zs = Max (deg_pair ` set zs)"

definition is_min_vpc :: "('x point \<times> 'x point) list \<Rightarrow> bool"
  where "is_min_vpc zs \<longleftrightarrow> is_vpc zs \<and>
                   (\<forall>zs'. is_vpc zs' \<longrightarrow> fst (hd zs') = fst (hd zs) \<longrightarrow> snd (last zs') = snd (last zs) \<longrightarrow>
                          length zs < length zs' \<or> (length zs = length zs' \<and> deg_vpc zs \<le> deg_vpc zs'))"

end

end (* two_polys *)

end (* theory *)
